#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pathname'
require 'shellwords'
require 'logger'
require 'optparse'
require 'date'
require 'subprocess'
require 'tempfile'
require 'fileutils'

require_relative 'andyrb/util'
require_relative 'andyrb/mood'
require_relative 'andyrb/options'
require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/core/monkeypatch'

AndyCore.monkeypatch(Array, AndyCore::Array::Cleanup)

opts = Options.new(ARGV.dup.cleanup(unique: false)) do |defaults|
  defaults[:cron] = false
end
opts.parse_args! do |h, i|
  h.on('-c', '--cron', "Don't output pretty text and enable logging.") { i[:cron] = true }
end
# Args = Options.parse(ARGV.dup.cleanup(unique: false))

Now = Time.now.strftime('%Y%m%d_%H%M').freeze

begin
  Log = opts[:args][:cron] ? Logger.new('/var/log/ttrss/ttrss_backup.log', 'monthly') : nil
rescue Errno::EACCES
  Log = nil
end

PgDump = Util::FindApp.which('pg_dump').freeze
Xz = Util::FindApp.which('xz').freeze

Tempfile.open('ttrss_') do |f|
  tmppath = Pathname.new(f.path).freeze
  xzpath = tmppath.sub_ext('.xz').freeze

  Subprocess.check_call(%W[#{PgDump} -C -c --if-exists -d feeds -U postgres -h 192.168.0.104], stdout: Subprocess::PIPE) do |p|
    puts(Mood.happy { "Dumping database to #{tmppath}" }) unless Log.respond_to?(:info)
    Log.info { "Dumping database to #{tmppath}" } if Log.respond_to?(:info)
    f.write p.communicate[0]
    f.fsync
  end

  # puts f.path
  out = "/data/ttrssbackup/feeds-#{Now}.xz"
  puts(Mood.happy { "Compressing #{tmppath} to #{out}" }) unless Log.respond_to?(:info)
  Log.info { "Compressing #{tmppath} to #{out}" } if Log.respond_to?(:info)
  Subprocess.check_call(%W[#{Xz} -k -C sha256 -T 0 #{tmppath}])
  begin
    FileUtils.mv(xzpath.to_s, out)
    FileUtils.chown('evildarkarchon', 'evildarkarchon', out)
    FileUtils.chmod(0o644, out)
  ensure
    FileUtils.rm(xzpath.to_s) if xzpath.exist?
  end
end
cpath = Pathname.new('/data/ttrssbackup').freeze
clean = cpath.find.to_a
clean.keep_if(&:file?)
clean.freeze

clean.each do |f|
  diff = Util.datediff(f.mtime).freeze
  puts(Mood.happy { "Removing #{f}" }) if diff > 14 && !Log.respond_to?(:info)
  Log.info { "Removing #{f}" } if diff > 14 && Log.respond_to?(:info)
  f.delete if diff > 14
end
