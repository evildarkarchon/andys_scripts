#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pathname'
require 'shellwords'
require 'logger'
require 'optparse'
require 'date'
require 'subprocess'
require 'tempfile'
require 'fileutils'

require_relative 'andyrb/util'
require_relative 'andyrb/mood'
require_relative 'andyrb/core/cleanup'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.cron = false

    optparse = OptionParser.new do |opts|
      opts.on('-c', '--cron', "Don't output pretty text and enable logging.") { options.cron = true }
    end
    optparse.parse!(args)
    options
  end
end
ARGV.cleanup!(unique: false)
Args = Options.parse(ARGV)
Now = Time.now.strftime('%Y%m%d_%H%M').freeze

begin
  Log = Args.cron ? Logger.new('/var/log/ttrss/ttrss_backup.log', 'monthly') : nil
rescue Errno::EACCES
  Log = nil
end

PgDump = Util::FindApp.which('pg_dump').freeze
Xz = Util::FindApp.which('xz').freeze

Tempfile.open('ttrss_') do |f|
  tmppath = Pathname.new(f.path).freeze
  xzpath = tmppath.sub_ext('.xz').freeze

  Subprocess.check_call(%W[#{PgDump} -C -c --if-exists -d feeds -U postgres], stdout: Subprocess::PIPE) do |p|
    puts(Mood.happy { "Dumping database to #{tmppath}" }) unless Log.respond_to?(:info)
    Log.info { "Dumping database to #{tmppath}" } if Log.respond_to?(:info)
    f.write p.communicate[0]
    f.fsync
  end

  # puts f.path
  out = "/data/ttrssbackup/feeds-#{Now}.xz"
  puts(Mood.happy { "Compressing #{tmppath} to #{out}" }) unless Log.respond_to?(:info)
  Log.info { "Compressing #{tmppath} to #{out}" } if Log.respond_to?(:info)
  Subprocess.check_call(%W[#{Xz} -k -T 0 #{tmppath}])
  begin
    FileUtils.mv(xzpath.to_s, out)
    FileUtils.chown('evildarkarchon', 'evildarkarchon', out)
    FileUtils.chmod(0o644, out)
  ensure
    FileUtils.rm(xzpath.to_s) if xzpath.exist?
  end
end
cpath = Pathname.new('/data/ttrssbackup').freeze
clean = cpath.find.to_a
clean.keep_if(&:file?)
clean.freeze

clean.each do |f|
  diff = Util.datediff(f.mtime).freeze
  puts(Mood.happy { "Removing #{f}" }) if diff > 14 && !Log.respond_to?(:info)
  Log.info { "Removing #{f}" } if diff > 14 && Log.respond_to?(:info)
  f.delete if diff > 14
end
