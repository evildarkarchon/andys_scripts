#!/usr/bin/python3.5 -O
import pathlib
import json
import sqlite3
import argparse
from humanize.filesize import naturalsize
import sys
import subprocess
import time

from andy.colors import Color
from andy.sortentries import sortentries
from andy.hashfile import hashfile
from andy.flatten import flatten
from andy.runprogram import runprogram
from andy.prettylist import prettylist

colors=Color()

args=argparse.ArgumentParser(description="genvideoinfo: a simple video metadata extractor.")
args.add_argument("--database", "-db", default="videoinfo.sqlite", help="Location of the sqlite database to save the information into.")
args.add_argument("--debug", "-d", action="store_true", help="Run in debug mode.")
args.add_argument("--delete", "-del", action="store_true", help="Delete the files specified from the database")
args.add_argument("--test", "-t", action="store_true", help="Run in test mode.")
args.add_argument("--maintainence", "-m", action="store_true", help="Run in maintainence mode.")
args.add_argument("--regen", "-r", action="store_true", help="Regenerate the database.")
#args.add_argument("--regen", "-r", action="store_true", help="Regenerate database.")
args.add_argument("files", nargs="*", help="Files to get information from.")

options=vars(args.parse_args())

if options["delete"] and not options["files"]:
    print("{} You must specify files to delete.")
    raise ValueError

databasepath=pathlib.Path(options["database"])
if databasepath.exists():
    databasepath=databasepath.resolve()
    with open(str(databasepath), "rb") as source, open(str(databasepath).replace(databasepath.suffix, "{}{}".format(databasepath.suffix, ".bak")), "wb") as dest:
        dest.write(bytes(source.read()))

if options["debug"]:
    database=sqlite3.connect(":memory:")
else:
    database=sqlite3.connect(options["database"])
global vi
with database:
    db=database.cursor()
    db.execute('pragma auto_vacuum')
    av=db.fetchone()
    if av[0] is not 1:
        database.execute('pragma auto_vacuum = 1')
        database.execute('vacuum')
    db.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='videoinfo';")
    vi=db.fetchone()
if len(vi) >= 1:
    viexists=True
else:
    viexists=False

if not options["delete"] and viexists:
    with database:
        database.row_factory = sqlite3.Row
        db=database.cursor()
        db.execute("select * from videoinfo")
        test=db.fetchone()
        if options["debug"]:
            print(type(test))
        if test:
            test2=test.keys()
            for column in ["container"]:
                if not {column}.issubset(test2):
                    print("{} Container column not found, regenerating database.".format(colors.mood("neutral")))
                    db.execute("drop table if exists videoinfo")
                    db.execute("vacuum")
        database.row_factory=None
if options["regen"] and not options["delete"]:
    with database:
        database.execute("drop table if exists videoinfo")
        database.execute("vacuum")

with database:
    database.execute('CREATE TABLE IF NOT EXISTS videoinfo (id integer primary key, filename text unique, duration text, bitrate_total text, bitrate_0 text, bitrate_1 text, codec_0 text, codec_1 text, container text, width integer, height integer, hash text unique)')

if options["maintainence"]:
    with database:
        database.execute('vacuum')
    sys.exit(0)

data={}

data["whitelist"] = ['.webm', '.mkv', '.flv', '.vob', '.ogg', '.drc', '.avi', '.wmv', '.yuv', '.rm', '.rmvb', '.asf', '.mp4', '.m4v', '.mpg', '.mp2', '.mpeg', '.mpe', '.mpv', '.3gp', '.3g2', '.mxf', '.roq', '.nsv', '.f4v']

data["unsorted"] = []

#db.execute("select filename videoinfo")
#data["existing"] = list(flatten(db.fetchall()))

#if options["regen"]:
#    data["existing"] = None
existinghash={}
with database:
    database.execute("select filename, hash from videoinfo")
    if not options["regen"] and not options["delete"]:
        for a, b in db.fetchall():
            existinghash[a] = b

    for filename in existinghash.keys():
        paths=pathlib.Path.cwd().iterdir()
        pathlist=[]
        for files in paths:
            pathlist.append(files.name)

        if filename not in pathlist:
            with database:
                print("{} {} not found, deleting from database.".format(colors.mood("neutral"), filename))
                database.execute("delete from videoinfo where filename=?", (filename,))

if not options["files"] and not options["delete"]:
    for filepath in pathlib.Path.cwd().iterdir():
        if filepath.suffix in data["whitelist"] and filepath.name and filepath.is_file() and filepath.name not in existinghash:
            data["unsorted"].append(filepath.name)
elif options["files"]:
    for files in options["files"]:
        filepath=pathlib.Path(files)
        if filepath.suffix in data["whitelist"] and filepath.is_file() and filepath.name not in existinghash:
            data["unsorted"].append(filepath.name)

if not options["delete"]:
    for filename in data["unsorted"]:
        if pathlib.Path(filename).suffix not in data["whitelist"]:
            data["unsorted"].remove(filename)

data["files"] = sortentries(data["unsorted"])

if len(data["files"]) is 0 and not options["delete"]:
    print("{} All files are already in the database or there are no files.".format(colors.mood("happy")))
    sys.exit(0)

if not options["delete"]:
    filehash = {}
    for filename in data["files"]:
        if not options["regen"]:
            if filename not in existinghash:
                print("{} Calculating hash for {}".format(colors.mood("happy"), filename))
                filehash[filename] = hashfile(filename)

                if filehash[filename] in existinghash:
                    with database:
                        database.execute("select filename from videoinfo where hash=?", (filehash[filename]))
                        existingnames=database.fetchall()
                        print("{} {} was found in the database.".format(colors.mood("neutral"), filename))

                        print("{} Filenames for existing file(s) are:".format(colors.mood("neutral")))
                        for filenames in existingnames:
                            print(colors.mood("neutral"), ''.join(filenames))
                            print("{} Removing {} from file list.".format(colors.mood("neutral"), filename))
                            data["files"].remove(filename)
                            filehash.pop(filename)
                            continue
        elif options["regen"] and not options["delete"]:
            print("{} Calculating hash for {}".format(colors.mood("happy"), filename))
            filehash[filename] = hashfile(filename)

    data["files"] = sortentries(data["files"])

if options["delete"]:
    for filename in data["files"]:
        with database:
            print("{} Deleting {} from database.".format(colors.mood("happy"), filename))
            database.execute("delete from videoinfo where filename=?", (filename,))
else:
    video_dict={}
    for filename in data["files"]:
        print("{} Extracting metadata for {}".format(colors.mood("happy"), filename))
        metadata=subprocess.Popen(["ffprobe", "-i", filename, "-hide_banner", "-of", "json", "-show_streams", "-show_format"], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        jsondata=json.loads(metadata.communicate()[0].decode("utf-8"))

        video_dict["filename"]=filename
        video_dict["duration"]=time.strftime("%H:%M:%S", time.gmtime(int(float(jsondata["format"].get("duration")))))
        video_dict["bitrate_total"]=naturalsize(jsondata["format"].get("bit_rate")).replace("B", "b/s")
        try:
            video_dict["bitrate_0"]=naturalsize(jsondata["streams"][0].get("bit_rate")).replace("B", "b/s")
        except (KeyError, IndexError):
            video_dict["bitrate_0"]=None
            pass
        #try:
        #    video_dict["height"]=jsondata["streams"][0]["height"]
        #except (KeyError, IndexError):
        #    video_dict["height"]=None
        #    pass
        #try:
        #    video_dict["width"]=jsondata["streams"][0]["width"]
        #except (KeyError, IndexError):
        #    video_dict["width"]=None
        #    pass
        video_dict["height"]=jsondata["streams"][0].get("height")
        video_dict["width"]=jsondata["streams"][0].get("width")
        video_dict["codec_0"]=jsondata["streams"][0].get("codec_name")

        video_dict["bitrate_1"]=naturalsize(jsondata["streams"][1].get("bit_rate")).replace("B", "b/s")
        video_dict["codec_1"]=jsondata["streams"][1].get("codec_name")
        video_dict["container"]=jsondata["format"].get("format_name")
        #try:
        #    video_dict["height"]=jsondata["streams"][1]["height"]
        #except (KeyError, IndexError):
        #    if not video_dict["height"]:
        #        video_dict["height"]=None
        #        pass
        #    else:
        #        pass
        if not video_dict["height"]:
            video_dict["height"]=jsondata["streams"][1].get("height")
        #try:
        #    video_dict["width"]=jsondata["streams"][1]["width"]
        #except (KeyError, IndexError):
        #    if not video_dict["width"]:
        #        video_dict["width"]=None
        #        pass
        #    else:
        #        pass
        if not video_dict["width"]:
            video_dict["width"]=jsondata["streams"][1].get("width")

        video_dict["hash"]=filehash.get(filename)

        if options["debug"]:
            print(video_dict["hash"])
            print(video_dict)
        with database:
            database.execute('insert into videoinfo (filename, duration, bitrate_total, bitrate_0, bitrate_1, codec_0, codec_1, container, width, height, hash) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', (video_dict["filename"], video_dict["duration"], video_dict["bitrate_total"], video_dict["bitrate_0"], video_dict["bitrate_1"], video_dict["codec_0"], video_dict["codec_1"], video_dict["container"], video_dict["width"], video_dict["height"], video_dict["hash"]))
#    database.commit()

database.close()
