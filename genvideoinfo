#!/usr/bin/env python3
# pylint: disable=e0401, w0611, c0301, c0103, c0111
import pathlib
import argparse
import locale
import sys
from sqlalchemy import create_engine  # , Column, Float, Integer, String
# from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from sqlalchemy.engine.reflection import Inspector

from andy2.videoinfo import VideoData, VideoInfo, VideoJSON, Info, sqa_session
from andy2.util import Mood, Util

locale.setlocale(locale.LC_ALL, 'en_US.utf-8')

args = argparse.ArgumentParser(description="genvideoinfo: a simple video metadata extractor.")
args.add_argument("--database", "-db", help="Location of the sqlite database to save the information into.")
args.add_argument("--verbose", "-v", action="store_true", help="Run in verbose mode.")
args.add_argument("--maintainence", "-m", action="store_true", help="Run in maintainence mode.")
args.add_argument("--regen", "-r", action="store_true", help="Regenerate the videoinfo table of the database.")
args.add_argument("--regen-json", "-rj", action="store_true", help="Regenerate the json cache.")
args.add_argument("--regen-all", "-ra", action="store_true", help="Regenerate the entire database.")
args.add_argument("files", nargs="*", help="Files to get information from.")

options = vars(args.parse_args())

if options["regen_all"]:
    options["regen"] = True
    options["regen_json"] = True

if 'database' in options and options["database"] is not None:
    if not pathlib.Path(options["database"]).exists():
        pathlib.Path(options["database"]).touch()
    options["database"] = str(pathlib.Path(options["database"]).resolve())
else:
    options["database"] = str(pathlib.Path.cwd().joinpath("videoinfo.sqlite"))

if not isinstance(options["database"], str):
    vd = VideoData.cwd(verbosemode=options["verbose"], regen=options["regen"], regenjson=options["regen_json"])
else:
    vd = VideoData(db=options["database"], verbose=options["verbose"], regen=options["regen"], regenjson=options["regen_json"])

database = create_engine("sqlite:///{}".format(options["database"]))
sm = sessionmaker(bind=database)
session = sm()
inspect = Inspector.from_engine(database)
if options["maintainence"]:
    with database.connect() as con:
        print("{} Rebuilding database file.".format(Mood.happy()))
        try:
            con.execute('VACUUM')
        except:
            raise
        else:
            sys.exit(0)


def geninitfilelist():  # pylint: disable=w0621
    """Generator function that that iterates over the current directory or the list specified on the command line to yield all the files in any directories specified as well as any files specified in the source list."""

    if options["files"]:
        for entry in options["files"]:
            pathentry = pathlib.Path(pathlib.Path(entry).resolve())
            if pathentry.is_dir():
                for path in pathentry.iterdir():
                    yield str(path)
            else:
                yield str(pathentry)
    else:
        paths = pathlib.Path.cwd().iterdir()
        for path in paths:
            yield str(path)


initfilelist = list(geninitfilelist())
if options["verbose"]:
    print("{} Initial file list is:\n{}".format(Mood.happy(), initfilelist))

existinghashes = dict(vd.genexisting())
filelist = Util.sortentries(list(vd.genfilelist(initfilelist, existinghashes)))
filehashes = dict(vd.genhashlist(filelist, existinghashes))
# print(existinghashes)
if options["verbose"]:
    print("{} Existing Hash Dictionary:\n{}".format(Mood.happy(), existinghashes))
    print("{} File List:\n{}".format(Mood.happy(), filelist))
    print("{} File Hash Dictionary:\n{}".format(Mood.happy(), filehashes))
for filename in filelist:
    if filename in existinghashes:
        filehash = existinghashes[pathlib.Path(filename).name]
    else:
        filehash = None
    if isinstance(filehashes[filename], str) and not filehashes[filename] == filehash:
        print("{} Putting information from {} into the database.".format(Mood.happy(), pathlib.Path(filename).name))
        vi = VideoInfo()
        vj = VideoJSON()
        filejson = vd.parse(filename)
        if options["verbose"]:
            # filedict = dict(VideoData.gendict(filename, filejson, filehashes[filename]))
            fileinfo = Info(filename, filejson, filehashes[filename])
            print("{} Video Information Dictionary:\n{}".format(Mood.happy(), filedict))
        else:
            filedict = dict(VideoData.gendict(filename, filejson, filehashes[filename]))
        with sqa_session(session) as sess:
            vi.filename = fileinfo.filename
            vi.duration = fileinfo.duration
            vi.duration_raw = fileinfo.duration_raw
            vi.numstreams = fileinfo.numstreams
            vi.container = fileinfo.container
            vi.width = fileinfo.width
            vi.height = fileinfo.height
            vi.frame_rate = fileinfo.frame_rate
            vi.type_0 = fileinfo.type_0
            vi.type_1 = fileinfo.type_1
            vi.codec_0 = fileinfo.codec_0
            vi.codec_1 = fileinfo.codec_1
            vi.bitrate_0 = fileinfo.bitrate_0
            vi.bitrate_0_raw = fileinfo.bitrate_0_raw
            vi.bitrate_1 = fileinfo.bitrate_1
            vi.bitrate_1_raw = fileinfo.bitrate_1_raw
            vi.bitrate_total = fileinfo.bitrate_total
            vi.filehash = fileinfo.hash
            if not session.query(VideoJSON).filter(VideoJSON.filename == fileinfo.filename).count() >= 1 or options["regen_json"]:
                print("{} Caching JSON data.".format(Mood.happy()))
                vj.json = fileinfo.jsondata
                vj.filename = fileinfo.filename
                sess.add(vj)
            sess.add(vi)

        del vi
        del vj
        del filejson
        del filedict
    elif isinstance(filehashes[filename], str) and filehashes[filename] == filehash:
        print("{} {} is already in the database, skipping.".format(Mood.neutral(), filename))
    del filehash
