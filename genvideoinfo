#!/usr/bin/python3.5
import pathlib
import json
import sqlite3
import argparse
from humanize.filesize import naturalsize
import sys
import subprocess
import time
import atexit
import locale

from andy.colors import Color
from andy.sortentries import sortentries
from andy.hashfile import hashfile
from andy.flatten import flatten
from andy.runprogram import runprogram
from andy.prettylist import prettylist

colors=Color()
locale.setlocale(locale.LC_ALL, 'en_US.utf-8')

try:
    import magic
except ImportError:
    print("{} Could not import filemagic module, reverting to extension-based whitelisting.".format(colors.mood("sad")))
    magicpresent=False
    pass
else:
    magicpresent=True

args=argparse.ArgumentParser(description="genvideoinfo: a simple video metadata extractor.")
args.add_argument("--database", "-db", default="videoinfo.sqlite", help="Location of the sqlite database to save the information into.")
args.add_argument("--debug", "-d", action="store_true", help="Run in debug mode.")
args.add_argument("--delete", "-del", action="store_true", help="Delete the files specified from the database")
args.add_argument("--test", "-t", action="store_true", help="Run in test mode.")
args.add_argument("--maintainence", "-m", action="store_true", help="Run in maintainence mode.")
args.add_argument("--regen", "-r", action="store_true", help="Regenerate the database.")
#args.add_argument("--refill", "-rf", action="store_true", help="Refill database with new information. (WIP)")
args.add_argument("files", nargs="*", help="Files to get information from.")

options=vars(args.parse_args())

data={}

if options["delete"] and not options["files"]:
    print("{} You must specify files to delete from the database.")
    raise ValueError

databasepath=pathlib.Path(options["database"])
if databasepath.exists():
    databasepath=databasepath.resolve()
    with open(str(databasepath), "rb") as source, open(str(databasepath).replace(databasepath.suffix, "{}{}".format(databasepath.suffix, ".bak")), "wb") as dest:
        dest.write(bytes(source.read()))

database=sqlite3.connect(options["database"])
atexit.register(database.close)

if options["regen"] and not options["delete"]:
    with database:
        print("{} Deleting existing videoinfo table.".format(colors.mood("neutral")))
        database.execute("drop table if exists videoinfo")
        database.execute("vacuum")

if options["maintainence"]:
    with database:
        database.execute('vacuum')
    sys.exit(0)

with database:
    db=database.cursor()
    db.execute('pragma auto_vacuum')
    av=db.fetchone()
    if av[0] is not 1:
        db.execute('pragma auto_vacuum = 1')
        db.execute('vacuum')


with database:
    db=database.cursor()
    db.execute('pragma page_size')
    pgsize=db.fetchone()
    if pgsize[0] is not 4096:
        db.execute('pragma page_size = 4096')
        db.execute('vacuum')
    db.execute('pragma cache_size = -2000')

with database:
    db=database.cursor()
    db.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='videoinfo';")
    vi=db.fetchone()
    global viexists
    try:
        vitemp=len(vi)
    except TypeError:
        db.execute('CREATE TABLE IF NOT EXISTS videoinfo (id integer primary key, filename text unique, duration text, bitrate_total text, bitrate_0 text, bitrate_1 text, codec_0 text, codec_1 text, container text, width integer, height integer, frame_rate integer, hash text unique)')
        viexists=True
    else:
        if vitemp >=1:
            viexists=True
        else:
            viexists=False

missingcolumn=["container", "frame_rate"]
if not options["delete"] and viexists and not options["regen"]:
    with database:
        database.row_factory = sqlite3.Row
        db=database.cursor()
        db.execute("select * from videoinfo")
        test=db.fetchone()
        if options["debug"]:
            print(type(test))
        if test:
            test2=test.keys()
            for column in missingcolumn:
                if not {column}.issubset(test2):
                    print("{} Column {} not found, resetting database.".format(colors.mood("neutral"), column))
                    db.execute("drop table if exists videoinfo")
                    db.execute("vacuum")
        database.row_factory=None

with database:
    database.execute('CREATE TABLE IF NOT EXISTS videoinfo (id integer primary key, filename text unique, duration text, bitrate_total text, bitrate_0 text, bitrate_1 text, codec_0 text, codec_1 text, container text, width integer, height integer, frame_rate integer, hash text unique)')

data["whitelist"] = ['.webm', '.mkv', '.flv', '.vob', '.ogg', '.drc', '.avi', '.wmv', '.yuv', '.rm', '.rmvb', '.asf', '.mp4', '.m4v', '.mpg', '.mp2', '.mpeg', '.mpe', '.mpv', '.3gp', '.3g2', '.mxf', '.roq', '.nsv', '.f4v', '.wav', '.ra', '.mka']

if magicpresent:
    data["mime"] = ["video/x-flv", "video/mp4", "video/mp2t", "video/3gpp", "video/quicktime", "video/x-msvideo", "video/x-ms-wmv", "video/webm", "video/x-matroska", "video/msvideo", "video/avi", "application/vnd.rm-realmedia", "audio/x-pn-realaudio", "audio/x-matroska", "audio/ogg", "video/ogg", "audio/vorbis", "video/theora", "video/3gpp2", "audio/x-wav", "audio/wave", "video/dvd", "video/mpeg", "application/vnd.rn-realmedia-vbr", "audio/vnd.rn-realaudio", "audio/x-realaudio"]
else:
    data["mime"] = None

data["unsorted"] = []

#db.execute("select filename videoinfo")
#data["existing"] = list(flatten(db.fetchall()))

#if options["regen"]:
#    data["existing"] = None
existinghash={}
with database:
    db=database.cursor()
    db.execute("select filename, hash from videoinfo")
    if not options["regen"] and not options["delete"]:
        for a, b in db.fetchall():
            existinghash[a] = b
            if options["debug"]:
                print("{}: {}".format(b, existinghash[a]))

    for filename in existinghash.keys():
        paths=pathlib.Path.cwd().iterdir()
        pathlist=[]
        for files in paths:
            pathlist.append(files.name)

        if filename not in pathlist:
            with database:
                print("{} {} not found, deleting from database.".format(colors.mood("neutral"), filename))
                database.execute("delete from videoinfo where filename=?", (filename,))
if magicpresent:
    with magic.Magic(flags=magic.MAGIC_MIME_TYPE) as m:
        if not options["files"] and not options["delete"]:
            for filepath in pathlib.Path.cwd().iterdir():
                if m.id_filename(str(filepath)) in data["mime"] and filepath.is_file() and filepath.name not in existinghash:
                    data["unsorted"].append(filepath.name)
        elif options["files"] and not options["delete"]:
            for filename in options["files"]:
                filepath=pathlib.Path(filename)
                if m.id_filename(filename) in data["mime"] and filepath.is_file() and filepath.name not in existinghash:
                    data["unsorted"].append(filepath.name)
        if not options["delete"]:
            for filename in data["unsorted"]:
                if m.id_filename(filename) not in data["mime"]:
                    data["unsorted"].remove(filename)
else:
    if not options["files"] and not options["delete"]:
        for filepath in pathlib.Path.cwd().iterdir():
            if filepath.suffix in data["whitelist"] and filepath.is_file() and filepath.name not in existinghash:
                data["unsorted"].append(filepath.name)
    elif options["files"] and not options["delete"]:
        for files in options["files"]:
            filepath=pathlib.Path(files)
            if filepath.suffix in data["whitelist"] and filepath.is_file() and filepath.name not in existinghash:
                data["unsorted"].append(filepath.name)

    if not options["delete"]:
        for filename in data["unsorted"]:
            if pathlib.Path(filename).suffix not in data["whitelist"]:
                data["unsorted"].remove(filename)

data["files"] = sortentries(data["unsorted"])

if len(data["files"]) is 0 and not options["delete"]:
    print("{} All files are already in the database or there are no files.".format(colors.mood("happy")))
    sys.exit(0)

if not options["delete"]:
    filehash = {}
    for filename in data["files"]:
        if not options["regen"]:
            if filename not in existinghash:
                print("{} Calculating hash for {}".format(colors.mood("happy"), filename))
                filehash[filename] = hashfile(filename)

                if filehash[filename] in existinghash:
                    with database:
                        database.execute("select filename from videoinfo where hash=?", (filehash[filename]))
                        existingnames=database.fetchall()
                        print("{} {} was found in the database.".format(colors.mood("neutral"), filename))

                        print("{} Filenames for existing file(s) are:".format(colors.mood("neutral")))
                        for filenames in existingnames:
                            print(colors.mood("neutral"), ''.join(filenames))
                            print("{} Removing {} from file list.".format(colors.mood("neutral"), filename))
                            data["files"].remove(filename)
                            filehash.pop(filename)
                            continue
        elif options["regen"] and not options["delete"]:
            print("{} Calculating hash for {}".format(colors.mood("happy"), filename))
            filehash[filename] = hashfile(filename)

    data["files"] = sortentries(data["files"])

if options["delete"]:
    for filename in data["files"]:
        with database:
            print("{} Deleting {} from database.".format(colors.mood("happy"), filename))
            database.execute("delete from videoinfo where filename=?", (filename,))
else:
    video_dict={}
    for filename in data["files"]:
        print("{} Extracting metadata for {}".format(colors.mood("happy"), filename))
        metadata=subprocess.Popen(["ffprobe", "-i", filename, "-hide_banner", "-of", "json", "-show_streams", "-show_format"], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        jsondata=json.loads(metadata.communicate()[0].decode("utf-8"))

        video_dict["filename"]=filename
        video_dict["duration"]=time.strftime("%H:%M:%S", time.gmtime(int(float(jsondata["format"].get("duration")))))
        video_dict["bitrate_total"]=naturalsize(jsondata["format"].get("bit_rate")).replace("B", "b/s")
        video_dict["container"]=jsondata["format"].get("format_name")
        try:
            video_dict["bitrate_0"]=naturalsize(jsondata["streams"][0].get("bit_rate")).replace("B", "b/s")
        except (KeyError, IndexError):
            video_dict["bitrate_0"]=None
            pass
        #try:
        #    video_dict["height"]=jsondata["streams"][0]["height"]
        #except (KeyError, IndexError):
        #    video_dict["height"]=None
        #    pass
        #try:
        #    video_dict["width"]=jsondata["streams"][0]["width"]
        #except (KeyError, IndexError):
        #    video_dict["width"]=None
        #    pass
        try:
            video_dict["height"]=jsondata["streams"][0].get("height")
        except (KeyError, IndexError):
            video_dict["height"]=None
            pass

        try:
            video_dict["width"]=jsondata["streams"][0].get("width")
        except (KeyError, IndexError):
            video_dict["width"]=None
            pass

        video_dict["codec_0"]=jsondata["streams"][0].get("codec_name")

        try:
            video_dict["bitrate_1"]=naturalsize(jsondata["streams"][1].get("bit_rate")).replace("B", "b/s")
        except (KeyError, IndexError):
            video_dict["bitrate_1"]=None
            pass
        try:
            video_dict["codec_1"]=jsondata["streams"][1].get("codec_name")
        except (KeyError, IndexError):
            video_dict["codec_1"]=None
            pass


        #try:
        #    video_dict["height"]=jsondata["streams"][1]["height"]
        #except (KeyError, IndexError):
        #    if not video_dict["height"]:
        #        video_dict["height"]=None
        #        pass
        #    else:
        #        pass
        if not video_dict["height"]:
            try:
                video_dict["height"]=jsondata["streams"][1].get("height")
            except (KeyError, IndexError):
                video_dict["height"]=None
                pass
        #try:
        #    video_dict["width"]=jsondata["streams"][1]["width"]
        #except (KeyError, IndexError):
        #    if not video_dict["width"]:
        #        video_dict["width"]=None
        #        pass
        #    else:
        #        pass
        if not video_dict["width"]:
            try:
                video_dict["width"]=jsondata["streams"][1].get("width")
            except (KeyError, IndexError):
                video_dict["width"]=None
                pass

        video_dict["hash"]=filehash.get(filename)

        if jsondata["streams"][0]["avg_frame_rate"]:
            if not jsondata["streams"][0]["avg_frame_rate"] == "0/0" and not jsondata["streams"][0]["avg_frame_rate"] == "0":
                try:
                    framerate=round(eval(jsondata["streams"][0]["avg_frame_rate"]), 2)
                    if framerate.is_integer():
                        framerate=int(framerate)
                    video_dict["frame_rate"]=framerate
                except ZeroDivisionError:
                    video_dict["frame_rate"]=None
                    pass
            elif jsondata["streams"][0]["avg_frame_rate"] == "0":
                video_dict["frame_rate"]=None
        elif jsondata["streams"][1]["avg_frame_rate"]:
            if not jsondata["streams"][1]["avg_frame_rate"] == "0/0" and not jsondata["streams"][1]["avg_frame_rate"] == "0":
                try:
                    framerate=round(eval(jsondata["streams"][1]["avg_frame_rate"]), 2)
                    if framerate.is_integer():
                        framerate=int(framerate)
                    video_dict["frame_rate"]=framerate
                except ZeroDivisionError:
                    video_dict["frame_rate"]=None
                    pass
            elif jsondata["streams"][1]["avg_frame_rate"] == "0":
                video_dict["frame_rate"]=None
            else:
                video_dict["frame_rate"]=None

        if options["debug"]:
            print(video_dict["hash"])
            print(video_dict)
        with database:
            database.execute('insert into videoinfo (filename, duration, bitrate_total, bitrate_0, bitrate_1, codec_0, codec_1, container, width, height, frame_rate, hash) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', (video_dict["filename"], video_dict["duration"], video_dict["bitrate_total"], video_dict["bitrate_0"], video_dict["bitrate_1"], video_dict["codec_0"], video_dict["codec_1"], video_dict["container"], video_dict["width"], video_dict["height"], video_dict["frame_rate"], video_dict["hash"]))
