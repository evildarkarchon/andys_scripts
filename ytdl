#!/usr/bin/env ruby
# frozen_string_literal: true
require 'optparse'
require 'subprocess'
require 'pathname'
require 'filemagic'
require 'uri'
require 'json'

begin
  rv = Gem::Version.new(RUBY_VERSION.to_s.freeze)
  rvm = Gem::Version.new('2.3.0')
  require 'ruby_dig' if rv < rvm
rescue LoadError => e
  raise e if rv < rvm
end

begin
  require 'xspf'
rescue LoadError
  XSPF_Exists = false
else
  XSPF_Exists = true
end

require_relative 'andyrb/videoinfo/probe'
require_relative 'andyrb/mood'
require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/util/program'
require_relative 'andyrb/util/findapp'
require_relative 'andyrb/util/recursive_symbolize_keys'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.date = Time.now.strftime('%Y%m%d').freeze
    # options.time = Time.now.strftime('%H%M').freeze
    options.directory = Pathname.new('/data/Videos/Youtube')
    options.subdirectory = nil
    options.no_date = false
    options.force = false
    options.pretend = false
    options.stats = true
    options.archive = nil
    options.no_download = false
    options.mux = false
    options.config = Pathname.new(Dir.home) + '.config/convertmkv.json'
    options.keep_original = false
    options.keep_split = false
    options.ffmpegdl = false
    options.webm = false
    options.playlist = true
    options.playlistpath = nil
    options.resetplaylist = false

    optparse = OptionParser.new do |opts|
      opts.on('-d', '--directory [DIRECTORY]', 'Name of the directory to download to') { |dir| options.directory = Pathname.new(dir) }
      opts.on('-a', '--archive [DIRECTORY]', 'Directory for the downloaded video list') { |dir| options.archive = Pathname.new(dir) }
      opts.on('-s', '--subdirectory [SUBDIRECTORY]', 'Optional subdirectory to tack on the end (only used if directory is set to the default)') { |dir| options.subdirectory = dir.to_s.freeze }
      opts.on('-n', '--no-date', "Don't create a subdirectory with the date (only needed if directory is set to the default)") { options.no_date = true }
      opts.on('-f', '--force', "Don't add the url(s) to the list of succesfully downloaded videos or read from said list.") { options.force = true }
      opts.on('-p', '--pretend', "Don't actually run youtube-dl or mkvpropedit") { options.pretend = true } # Mostly for testing code that doesn't rely on the programs actually running.
      opts.on('--no-download', "Run operations that don't require downloading.") { options.no_download = true }
      opts.on('--no-stats', "Don't calculate statistics for MKV files.") { options.stats = false }
      opts.on('--webm', 'use webm instead of mkv for merging files (videos that have separate files per stream).') { options.webm = true }
      opts.on('-m', '--mux', 'mux non-mkv files') { options.mux = true }
      opts.on('--convertmkv-config', 'Location for the convertmkv configuration file.') { |c| options.config = c } # Reusing the convertmkv config file since the options used are the same.
      opts.on('-k', '--keep-original', 'Keep the original file if muxing non-mkv files.') { options.keep_original = true }
      opts.on('-ks', '--keep-split', 'Keep the original split download files (if there are any)') do
        options.keep_split = true
        options.no_mux = true
      end
      opts.on('--ffmpeg-download', 'Download using ffmpeg') { options.ffmpegdl = true } # hoping this will fix certain video downloads
      opts.on('--no-playlist', "Don't create a playlist") { options.playlist = false }
      opts.on('--playlist-path [FILE]', 'Location to save the playlist') { |i| options.playlistpath = Pathname.new(i) }
      opts.on('--reset-playlist', 'Do not modify an existing playlist (if it exists)') { options.resetplaylist = true }
    end
    optparse.parse!(args)
    options
  end
end

ARGV.cleanup!
Args = Options.parse(ARGV)
puts Args if Args.pretend

Urls = ARGV.dup
Urls.keep_if { |url| url.is_a?(String) }
Urls.keep_if { |url| url =~ /\A#{URI.regexp(%w(http https))}\z/ }
Urls.freeze
print "#{Urls}\n" if Args.pretend

raise 'No URLs specified (or code is bugged)' if (Urls.nil? || Urls.empty?) && !Args.pretend && !Args.no_download
raise 'Somehow, Args.directory is nil' if Args.directory.nil?
raise 'Somehow, Args.directory is empty' if Args.directory.respond_to?(:empty?) && Args.directory.empty?
raise 'Somehow, Args.directory is not a Pathname' unless Args.directory.is_a?(Pathname)

outdir = Args.directory.to_s.freeze

Args.directory &&= Args.directory + Args.date if outdir == '/data/Videos/Youtube' && !Args.no_date

Args.directory &&= Args.directory + Args.subdirectory if Args.subdirectory && Args.subdirectory.is_a?(String) && outdir.include?('/data/Videos/Youtube')

Args.freeze
Args.directory.freeze

puts Mood.neutral { "Is Args frozen? #{Args.frozen?}" } if Args.pretend
# puts Args.frozen? if Args.pretend
# Args.directory.freeze unless Args.directory.frozen?
puts Mood.neutral { "Is Args.directory frozen? #{Args.directory.frozen?}" } if Args.pretend
puts Mood.neutral { Args.directory } if Args.pretend

case
when Args.directory.exist? && !Args.directory.directory?
  raise "#{Args.directory} exists but is not a directory."
when !Args.directory.exist?
  puts Mood.happy { "Creating Directory #{Args.directory}" }
  Args.directory.mkpath
end

Util::FindApp.which('youtube-dl') do |yt|
  yt.freeze
  raise "Couldn't find youtube-dl" unless yt
  raise 'youtube-dl is not executable' unless yt && File.executable?(yt)
  outdir = Args.directory.to_s.freeze
  archdir = Args.directory.parent.parent.freeze if Args.subdirectory && outdir.include?('/data/Videos/Youtube') && !Args.no_date

  archive =
    case
    when Args.archive
      puts Mood.neutral { 'Archive from command line' } if Args.pretend
      Args.archive + 'downloaded.txt'
    when !Args.no_date && archdir
      puts Mood.neutral { 'Archive in subdirectory parent' } if Args.pretend
      archdir + 'downloaded.txt'
    when !Args.no_date && outdir.include?('/data/Videos/Youtube')
      puts Mood.neutral { 'Archive in parent directory' } if Args.pretend
      Args.directory.parent + 'downloaded.txt'
    else
      puts Mood.neutral { 'Archive in download directory' } if Args.pretend
      Args.directory + 'downloaded.txt'
    end
  archive.freeze

  puts Mood.neutral { archive } if Args.pretend
  ytdl = %W(#{yt})
  ytdl << %W(--download-archive #{archive}) unless Args.force
  ytdl << %w(--merge-output-format webm) if Args.webm
  ytdl << '-k' if Args.keep_split
  ytdl << %w(--external-downloader ffmpeg --external-downloader-args -hide_banner --hls-prefer-ffmpeg) if Args.ffmpegdl
  ytdl << Urls
  ytdl.cleanup!(unique: false)
  ytdl.freeze

  Util::Program.runprogram(ytdl, workdir: outdir) unless Args.pretend || Args.no_download
  print "#{ytdl}\n" if Args.pretend && !Urls.nil? && !Urls.empty? && !Args.no_download
end

Files = Args.directory.find.to_a
puts Mood.neutral('Step 1:') if Args.pretend
print "#{Files}\n" if Args.pretend
puts Mood.neutral('No files found in this directory, will not do any statistics calculation or muxing.') if Files.nil? || Files.empty?
exit if Files.nil? || Files.empty?
Files.keep_if(&:file?)
Files.freeze

if Args.stats
  mkv = Files.dup
  whitelist = %w(video/webm video/x-matroska audio/x-matroska).freeze
  mkv.keep_if do |file|
    file.freeze
    magic = FileMagic.new(:mime_type)
    whitelist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2:') if Args.pretend
  print "#{mkv}\n" if Args.pretend
  mkv.delete_if do |file|
    file.freeze
    jsondata = VideoInfo.probe(file)
    jsondata.freeze unless frozen?
    jsondata.dig(:streams, 0, :tags, :BPS)
  end
  mkv.freeze
  puts Mood.neutral('Step 3:') if Args.pretend
  print "#{mkv}\n" if Args.pretend
  puts Mood.neutral('No matroska files to calculate statistics for.') if mkv.nil? || mkv.empty?

  Util::FindApp.which('mkvpropedit') do |mpe|
    mpe.freeze
    raise "Couldn't find mkvpropedit" unless mpe
    raise 'mkvpropedit is not executable' unless mpe && File.executable?(mpe)
    if mkv.respond_to?(:each) && mkv.respond_to?(:empty?) && !mkv.empty?
      mkv.each do |file|
        puts Mood.happy { "Adding statistic tags to #{file}" }
        cmd = %W(#{mpe} --add-track-statistics-tags #{file}).freeze
        begin
          Util::Program.runprogram(cmd) unless Args.pretend
          print "#{cmd}\n" if Args.pretend
        rescue Subprocess::NonZeroExit => e
          puts e.message
          next
        end
      end
    end
  end
end
if Args.mux
  muxfiles = Files.dup
  magic = FileMagic.new(:mime_type)
  whitelist = %w(video/x-flv video/mp4 audio/x-m4a video/mp2t video/3gpp video/quicktime video/x-msvideo video/x-ms-wmv video/3gpp2 audio/x-wav)
  whitelist += %w(audio/wave video/dvd video/mpeg application/vnd.rn-realmedia-vbr audio/vnd.rn-realaudio audio/x-realaudio)
  whitelist.freeze
  blacklist = %w(video/webm video/x-matroska audio/x-matroska).freeze
  muxfiles.delete_if do |file|
    blacklist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2:') if Args.pretend
  print "#{muxfiles}\n" if Args.pretend

  muxfiles.keep_if do |file|
    whitelist.include?(magic.file(file.to_s))
  end
  muxfiles.freeze

  puts Mood.neutral('Step 3:') if Args.pretend
  print "#{muxfiles}\n" if Args.pretend

  Util::FindApp.which('mkvmerge') do |mkvm|
    mkvm.freeze
    raise "Couldn't find mkvmerge" unless mkvm
    raise 'mkvmerge is not executable' unless mkvm && File.executable?(mkvm)
    config =
      case
      when Args.config.exist?
        configfile = Args.config.open
        confighash = JSON.parse(configfile.read)
        confighash = Util.recursive_symbolize_keys(confighash)
        configfile.close
        print "#{confighash}\n" if Args.pretend && confighash
        confighash
      end
    config.freeze

    if muxfiles.respond_to?(:each) && muxfiles.respond_to?(:empty?) && !muxfiles.empty?
      muxfiles.each do |file|
        file.freeze
        out = Args.directory + file.basename.sub_ext('.mkv')
        cmd = config[:mkvmerge] ? %W(#{mkvm} #{config[:mkvmerge]} -o #{out} = #{file}) : %W(#{Util::FindApp.which(mkvmerge)} -o #{out} = #{file})
        cmd.cleanup!(unique: false)
        cmd.freeze
        print "#{cmd}\n" if Args.pretend

        begin
          Util::Program.runprogram(cmd) unless Args.pretend
        rescue Subprocess::NonZeroExit => e
          puts e.message
          next
        else
          file.delete unless Args.pretend || Args.keep_original
        end
      end
    end
  end
end

def genplaylisthash(filename, rootdir = '/data/Videos')
  jsondata = VideoInfo.probe(filename)
  filepath = Pathname.new(filename)
  rootpath = Pathname.new(rootdir)
  out = {}
  out[:location] = URI.escape('file:///z:/'.dup + filepath.realpath.relative_path_from(rootpath).to_s)
  if jsondata.dig(:format, :tags)
    out[:title] = jsondata[:format][:tags][:title] if jsondata.dig(:format, :tags, :title)
    out[:annotation] = jsondata[:format][:tags][:DESCRIPTION] if jsondata.dig(:format, :tags, :DESCRIPTION)
    out[:creator] = jsondata[:format][:tags][:ARTIST] if jsondata.dig(:format, :tags, :ARTIST)
    out[:duration] = jsondata[:format][:duration].to_f.round.to_s if jsondata.dig(:format, :duration)
  end
  out
end

def genplaylist(files)
  outpath =
    case
    when Args.playlistpath
      Args.playlistpath
    when Args.directory.to_s.include?('/data/Videos/Youtube') && Args.subdirectory
      Pathname.new("/data/Videos/Youtube/Playlists/#{Args.subdirectory}/#{Args.date}.xspf")
    when Args.directory.to_s.include?('/data/Videos/Youtube') && !Args.subdirectory
      Pathname.new("/data/Videos/Youtube/Playlists/#{Args.date}.xspf")
    else
      Pathname.new("#{Args.directory}/Playlists/#{Args.date}.xspf")
    end
  tracklist = nil
  playlist = nil
  xspf = nil
  existing = []
  tracklist = XSPF::Tracklist.new unless tracklist.instance_of?(XSPF::Tracklist)
  if outpath.exist? && !Args.resetplaylist
    o = File.new(outpath.to_s)
    xspf = XSPF.new(o)
    playlist = xspf.playlist
    tracklist = playlist.tracklist
    existing = tracklist.tracks
    existing.map!(&:location) if existing.respond_to?(:map!) && !existing.empty?
    o.close
  end
  files.each do |file|
    puts Mood.happy { "Adding #{file} to playlist" }
    track = file.to_s.include?('/data/Videos') ? XSPF::Track.new(genplaylisthash(file)) : XSPF::Track.new(genplaylisthash(file, Args.directory.to_s))
    tracklist << track
  end
  playlist = XSPF::Playlist.new(tracklist: tracklist) unless playlist.instance_of?(XSPF::Playlist)
  xspf = XSPF.new(playlist: playlist) unless xspf.instance_of?(XSPF)
  puts Mood.happy { "Creating Directory #{outpath.dirname}" } unless Args.pretend || outpath.dirname.exist?
  outpath.dirname.mkpath unless Args.pretend
  unless Args.pretend
    File.open(outpath.to_s, 'w') do |f|
      puts Mood.happy { "Writing playlist to #{outpath}" }
      f.write(xspf.to_xml)
    end
  end
  puts xspf.to_xml if Args.pretend
end

if XSPF_Exists && Args.playlist
  whitelist = %w(video/x-flv video/mp4 audio/x-m4a video/mp2t video/3gpp video/quicktime video/x-msvideo video/x-ms-wmv video/3gpp2 audio/x-wav)
  whitelist += %w(audio/wave video/dvd video/mpeg application/vnd.rn-realmedia-vbr audio/vnd.rn-realaudio audio/x-realaudio)
  whitelist += %w(video/webm video/x-matroska audio/x-matroska)
  whitelist.freeze
  magic = FileMagic.new(:mime_type)

  # tracklist = XSPF::Tracklist.new unless tracklist.instance_of?(XSPF::Tracklist)
  filelist = Files.dup
  # filelist.keep_if { |i| i.to_s.include?(Args.subdirectory) } if Args.subdirectory
  filelist.keep_if { |i| i.dirname.to_s == Args.directory.to_s }
  unless existing.empty? || Args.resetplaylist
    filelist.delete_if do |i|
      existing.to_s.include?(i.relative_path_from(Pathname.new('/data/Videos')).to_s) if Args.directory.to_s.include?('/data/Videos') && !existing.empty?
      existing.to_s.include?(i.relative_path_from(Args.directory).to_s) unless Args.directory.to_s.include?('/data/Videos') && !existing.empty?
    end
  end
  filelist.keep_if do |file|
    whitelist.include?(magic.file(file.to_s))
  end
  filelist.freeze
  puts Mood.neutral { 'No files to add to the playlist' } if filelist.empty?
  genplaylist(filelist) unless filelist.empty?
end
