#!/usr/bin/env ruby
# frozen_string_literal: true
require 'optparse'
require 'subprocess'
require 'pathname'
require 'filemagic'
require 'uri'
require 'json'

begin
  rv = Gem::Version.new(RUBY_VERSION.to_s)
  rvm = Gem::Version.new('2.3.0')
  require 'ruby_dig' if rv < rvm
rescue LoadError
  nil
end

require_relative 'andyrb/videoinfo/probe'
require_relative 'andyrb/mood'
require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/util/program'
require_relative 'andyrb/util/findapp'
require_relative 'andyrb/util/recursive_symbolize_keys'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.date = Time.now.strftime("%Y%m%d").freeze # rubocop:disable Style/StringLiterals, Lint/UnneededDisable
    options.directory = Pathname.new('/data/Videos/Youtube')
    options.subdirectory = nil
    options.no_date = false
    options.force = false
    options.pretend = false
    options.stats = true
    options.archive = nil
    options.mkv_only = false
    options.mux = false
    options.config = Pathname.new(Dir.home) + '.config/convertmkv.json'
    options.keep_original = false
    options.keep_split = false
    options.ffmpegdl = false
    options.webm = false

    optparse = OptionParser.new do |opts|
      opts.on('-d', '--directory [DIRECTORY]', 'Name of the directory to download to') { |dir| options.directory = Pathname.new(dir) }
      opts.on('-a', '--archive [DIRECTORY]', 'Directory for the downloaded video list') { |dir| options.archive = Pathname.new(dir) }
      opts.on('-s', '--subdirectory [SUBDIRECTORY]', 'Optional subdirectory to tack on the end (only used if directory is set to the default)') { |dir| options.subdirectory = dir.to_s.freeze }
      opts.on('-n', '--no-date', "Don't create a subdirectory with the date (only needed if directory is set to the default)") { options.no_date = true }
      opts.on('-f', '--force', "Don't add the url(s) to the list of succesfully downloaded videos or read from said list.") { options.force = true }
      opts.on('--pretend', '-p', "Don't actually run youtube-dl or mkvpropedit") { options.pretend = true } # Mostly for testing code that doesn't rely on the programs actually running.
      opts.on('--mkv-only', "Don't run youtube-dl but run mkvpropedit.") { options.mkv_only = true }
      opts.on('--no-stats', "Don't calculate statistics for MKV files.") { options.stats = false }
      opts.on('--webm', 'use webm instead of mkv for merging files (videos that have separate files per stream).') { options.webm = true }
      opts.on('--mux', '-m', 'mux non-mkv files') { options.mux = true }
      opts.on('--convertmkv-config', 'Location for the convertmkv configuration file.') { |c| options.config = c.freeze } # Reusing the convertmkv config file since the options used are the same.
      opts.on('--keep-original', '-k', 'Keep the original file if muxing non-mkv files.') { options.keep_original = true }
      opts.on('--keep-split', '-ks', 'Keep the original split download files (if there are any)') do
        options.keep_split = true
        options.no_mux = true
      end
      opts.on('--ffmpeg-download', 'Download using ffmpeg (hoping this will fix certain video downloads)') { options.ffmpegdl = true }
    end
    optparse.parse!(args)
    options
  end
end

ARGV.cleanup!
Args = Options.parse(ARGV)
puts Args if Args.pretend

Urls = ARGV
Urls.keep_if { |url| url.is_a?(String) }
Urls.keep_if { |url| url =~ /\A#{URI.regexp(%w(http https))}\z/ }
Urls.freeze
print "#{Urls}\n" if Args.pretend

raise 'No URLs specified (or code is bugged)' if (Urls.nil? || Urls.empty?) && !Args.pretend && !Args.mkv_only
raise 'Somehow, Args.directory is nil' if Args.directory.nil?
raise 'Somehow, Args.directory is empty' if Args.directory.respond_to?(:empty?) && Args.directory.empty?
raise 'Somehow, Args.directory is not a Pathname' unless Args.directory.is_a?(Pathname)

Args.directory &&= Args.directory + Args.date if Args.directory.to_s == '/data/Videos/Youtube' && !Args.no_date

Args.directory &&= Args.directory + Args.subdirectory if Args.subdirectory && Args.subdirectory.is_a?(String) && Args.directory.to_s.include?('/data/Videos/Youtube')

Args.freeze

OutDir = Args.directory.to_s.freeze

puts Mood.neutral { "Is Args frozen? #{Args.frozen?}" } if Args.pretend
# puts Args.frozen? if Args.pretend
# Args.directory.freeze unless Args.directory.frozen?
puts Mood.neutral { "Is Args.directory frozen? #{Args.directory.frozen?}" } if Args.pretend
puts Mood.neutral { Args.directory } if Args.pretend

case
when Args.directory.exist? && !Args.directory.directory?
  raise "#{Args.directory} exists but is not a directory."
when !Args.directory.exist?
  puts Mood.happy { "Creating Directory #{Args.directory}" }
  Args.directory.mkpath
end

Util::FindApp.which('youtube-dl') do |yt|
  yt.freeze
  raise "Couldn't find youtube-dl" unless yt
  raise 'youtube-dl is not executable' unless yt && File.executable?(yt)

  archdir = Args.directory.parent.parent.freeze if Args.subdirectory && OutDir.include?('/data/Videos/Youtube') && !Args.no_date

  archive =
    case
    when Args.archive
      puts Mood.neutral { 'Archive from command line' } if Args.pretend
      Args.archive + 'downloaded.txt'
    when !Args.no_date && archdir
      puts Mood.neutral { 'Archive in subdirectory parent' } if Args.pretend
      archdir + 'downloaded.txt'
    when !Args.no_date && OutDir.include?('/data/Videos/Youtube')
      puts Mood.neutral { 'Archive in parent directory' } if Args.pretend
      Args.directory.parent + 'downloaded.txt'
    else
      puts Mood.neutral { 'Archive in download directory' } if Args.pretend
      Args.directory + 'downloaded.txt'
    end
  archive.freeze

  puts Mood.neutral { archive } if Args.pretend
  ytdl = %W(#{yt})
  ytdl << %W(--download-archive #{archive}) unless Args.force
  ytdl << %w(--merge-output-format webm) if Args.webm
  ytdl << '-k' if Args.keep_split
  ytdl << %w(--external-downloader ffmpeg --external-downloader-args -hide_banner --hls-prefer-ffmpeg) if Args.ffmpegdl
  ytdl << Urls
  ytdl.cleanup!(unique: false)
  ytdl.freeze

  Util::Program.runprogram(ytdl, workdir: OutDir) unless Args.pretend || Args.mkv_only
  print "#{ytdl}\n" if Args.pretend && !Urls.nil? && !Urls.empty? && !Args.mkv_only
end

Files = Args.directory.find.to_a

puts Mood.neutral('Step 1:') if Args.pretend
print "#{Files}\n" if Args.pretend
puts Mood.neutral('No files found in this directory, will not do any statistics calculation or muxing.') if Files.nil? || Files.empty?
exit if Files.nil? || Files.empty?
Files.keep_if(&:file?)
Files.freeze

if Args.stats
  mkv = Files.dup
  whitelist = %w(video/webm video/x-matroska audio/x-matroska).freeze
  mkv.keep_if do |file|
    file.freeze
    magic = FileMagic.new(:mime_type)
    whitelist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2:') if Args.pretend
  print "#{mkv}\n" if Args.pretend
  mkv.delete_if do |file|
    file.freeze
    jsondata = Util.recursive_symbolize_keys(VideoInfo.probe(file))
    jsondata.freeze unless frozen?
    case
    when jsondata.respond_to?(:dig)
      jsondata.dig(:streams, 0, :tags, :BPS)
    when !jsondata.respond_to?(:dig)
      json[:streams][0] && json[:streams][0][:tags] && json[:streams][0][:tags][:BPS] ? true : false
    end
  end
  mkv.freeze
  puts Mood.neutral('Step 3:') if Args.pretend
  print "#{mkv}\n" if Args.pretend
  puts Mood.neutral('No matroska files to calculate statistics for.') if mkv.nil? || mkv.empty?

  Util::FindApp.which('mkvpropedit') do |mpe|
    mpe.freeze
    raise "Couldn't find mkvpropedit" unless mpe
    raise 'mkvpropedit is not executable' unless mpe && File.executable?(mpe)
    if mkv.respond_to?(:each) && mkv.respond_to?(:empty?) && !mkv.empty?
      mkv.each do |file|
        puts Mood.happy { "Adding statistic tags to #{file}" }
        cmd = %W(#{mpe} --add-track-statistics-tags #{file}).freeze
        begin
          Util::Program.runprogram(cmd) unless Args.pretend
          print "#{cmd}\n" if Args.pretend
        rescue Subprocess::NonZeroExit => e
          puts e.message
          next
        end
      end
    end
  end
end
if Args.mux
  muxfiles = Files.dup
  magic = FileMagic.new(:mime_type)
  whitelist = %w(video/x-flv video/mp4 audio/x-m4a video/mp2t video/3gpp video/quicktime video/x-msvideo video/x-ms-wmv video/3gpp2 audio/x-wav)
  whitelist += %w(audio/wave video/dvd video/mpeg application/vnd.rn-realmedia-vbr audio/vnd.rn-realaudio audio/x-realaudio)
  whitelist.freeze
  blacklist = %w(video/webm video/x-matroska audio/x-matroska).freeze
  muxfiles.delete_if do |file|
    blacklist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2:') if Args.pretend
  print "#{muxfiles}\n" if Args.pretend

  muxfiles.keep_if do |file|
    whitelist.include?(magic.file(file.to_s))
  end
  muxfiles.freeze

  puts Mood.neutral('Step 3:') if Args.pretend
  print "#{muxfiles}\n" if Args.pretend

  Util::FindApp.which('mkvmerge') do |mkvm|
    mkvm.freeze
    raise "Couldn't find mkvmerge" unless mkvm
    raise 'mkvmerge is not executable' unless mkvm && File.executable?(mkvm)
    config =
      case
      when Args.config.exist?
        configfile = Args.config.open
        confighash = JSON.parse(configfile.read)
        confighash = Util.recursive_symbolize_keys(confighash)
        configfile.close
        print "#{confighash}\n" if Args.pretend && confighash
        confighash
      end
    config.freeze

    if muxfiles.respond_to?(:each) && muxfiles.respond_to?(:empty?) && !muxfiles.empty?
      muxfiles.each do |file|
        file.freeze
        out = Args.directory + file.basename.sub_ext('.mkv')
        cmd = config[:mkvmerge] ? %W(#{mkvm} #{config[:mkvmerge]} -o #{out} = #{file}) : %W(#{Util::FindApp.which(mkvmerge)} -o #{out} = #{file})
        cmd.cleanup!(unique: false)
        cmd.freeze
        print "#{cmd}\n" if Args.pretend

        begin
          Util::Program.runprogram(cmd) unless Args.pretend
        rescue Subprocess::NonZeroExit => e
          puts e.message
          next
        else
          file.delete unless Args.pretend || Args.keep_original
        end
      end
    end
  end
end
