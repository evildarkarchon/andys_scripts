#!/usr/bin/env ruby
# frozen_string_literal: true
require 'optparse'
require 'subprocess'
require 'pathname'
require 'filemagic'
require 'uri'
require 'json'
require 'cgi'

begin
  rv = Gem::Version.new(RUBY_VERSION.to_s.freeze)
  rvm = Gem::Version.new('2.3.0')
  require 'ruby_dig' if rv < rvm
rescue LoadError => e
  raise e if rv < rvm
end

begin
  require 'xspf'
rescue LoadError
  XSPF_Exists = false
else
  XSPF_Exists = true
end

require_relative 'andyrb/videoinfo/probe'
require_relative 'andyrb/mood'
require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/util/program'
require_relative 'andyrb/util/findapp'
require_relative 'andyrb/util/recursive_symbolize_keys'

class Options
  def self.parse(args)
    args.cleanup!
    options = OpenStruct.new
    options.date = Time.now.strftime('%Y%m%d').freeze
    # options.time = Time.now.strftime('%H%M').freeze
    options.directory = Pathname.new('/data/Videos/Youtube')
    options.subdirectory = nil
    options.datesubdir = true
    options.force = false
    options.pretend = false
    options.stats = true
    options.archive = nil
    options.no_download = false
    options.mux = false
    options.config = Pathname.new(Dir.home) + '.config/convertmkv.json'
    options.keep_original = false
    options.keep_split = false
    options.ffmpegdl = false
    options.webm = false
    options.playlist = true
    options.playlistpath = nil
    options.resetplaylist = false
    options.no_blacklist = false

    optparse = OptionParser.new do |opts|
      opts.on('-d', '--directory [DIRECTORY]', 'Name of the directory to download to') { |dir| options.directory = Pathname.new(dir) }
      opts.on('-a', '--archive [DIRECTORY]', 'Directory for the downloaded video list') { |dir| options.archive = Pathname.new(dir) }
      opts.on('-s', '--subdirectory [SUBDIRECTORY]', 'Optional subdirectory to tack on the end (only used if directory is set to the default)') { |dir| options.subdirectory = dir.to_s.freeze }
      opts.on('-n', '--no-date', "Don't create a subdirectory with the date (only needed if directory is set to the default)") { options.datesubdir = false }
      opts.on('-f', '--force', "Don't add the url(s) to the list of succesfully downloaded videos or read from said list.") { options.force = true }
      opts.on('-p', '--pretend', "Don't actually run youtube-dl or mkvpropedit") { options.pretend = true } # Mostly for testing code that doesn't rely on the programs actually running.
      opts.on('--no-download', "Run operations that don't require downloading.") { options.no_download = true }
      opts.on('--no-stats', "Don't calculate statistics for MKV files.") { options.stats = false }
      opts.on('--webm', 'use webm instead of mkv for merging files (videos that have separate files per stream).') { options.webm = true }
      opts.on('-m', '--mux', 'mux non-mkv files') { options.mux = true }
      opts.on('--convertmkv-config', 'Location for the convertmkv configuration file.') { |c| options.config = c } # Reusing the convertmkv config file since the options used are the same.
      opts.on('-k', '--keep-original', 'Keep the original file if muxing non-mkv files.') { options.keep_original = true }
      opts.on('-ks', '--keep-split', 'Keep the original split download files (if there are any)') do
        options.keep_split = true
        options.no_mux = true
      end
      opts.on('--ffmpeg-download', 'Download using ffmpeg') { options.ffmpegdl = true } # hoping this will fix certain video downloads
      opts.on('--no-playlist', "Don't create a playlist") { options.playlist = false }
      opts.on('--playlist-path [FILE]', 'Location to save the playlist') { |i| options.playlistpath = Pathname.new(i) }
      opts.on('--reset-playlist', 'Do not modify an existing playlist (if it exists)') { options.resetplaylist = true }
      opts.on('--no-blacklist', 'Do not put downloaded files in the playlist blacklist if playlist creation (or modification) is disabled.') { options.no_blacklist = true }
    end
    optparse.parse!(args)
    options
  end
end

Args = Options.parse(ARGV.dup)
puts Args if Args.pretend
Args.freeze

urls = lambda do
  out = ARGV.dup
  out.cleanup!
  out.keep_if { |url| url.is_a?(String) }
  out.keep_if { |url| url =~ /\A#{URI.regexp(%w(http https))}\z/ }
  out
end
Urls = urls.call.freeze
# print "#{Urls}\n" if Args.pretend
puts Urls.inspect if Args.pretend

raise 'No URLs specified (or code is bugged)' if (Urls.nil? || Urls.empty?) && !Args.pretend && !Args.no_download

raise 'Args.directory is not set properly (somehow)' unless Args.directory && Args.directory.is_a?(Pathname)
# raise 'Somehow, Args.directory is nil' if Args.directory.nil?
# raise 'Somehow, Args.directory is empty' if Args.directory.respond_to?(:empty?) && Args.directory.empty?
# raise 'Somehow, Args.directory is not a Pathname' unless Args.directory.is_a?(Pathname)

subdir = lambda do
  indir = Args.directory.to_s
  outdir = Args.directory
  outdir += Args.date if outdir && indir && indir == '/data/Videos/Youtube' && Args.datesubdir
  outdir += Args.subdirectory if outdir && indir && Args.subdirectory && Args.subdirectory.is_a?(String) && indir.include?('/data/Videos/Youtube')
  outdir
end

Directory = subdir.call.freeze

# Args.directory &&= Args.directory + Args.date if outdir == '/data/Videos/Youtube' && Args.datesubdir
# Args.directory &&= Args.directory + Args.subdirectory if Args.subdirectory && Args.subdirectory.is_a?(String) && outdir.include?('/data/Videos/Youtube')

puts Mood.neutral { "Is Args frozen? #{Args.frozen?}" } if Args.pretend
# puts Args.frozen? if Args.pretend
# Args.directory.freeze unless Args.directory.frozen?
puts Mood.neutral { "Is Directory frozen? #{Directory.frozen?}" } if Args.pretend
puts Mood.neutral { Directory } if Args.pretend

case
when Directory.exist? && !Directory.directory?
  raise "#{Directory} exists but is not a directory."
when !Directory.exist?
  puts Mood.happy { "Creating Directory #{Directory}" }
  Directory.mkpath
end

filenames = lambda do
  files = []
  Util::FindApp.which('youtube-dl') do |yt|
    Urls.each do |url|
      files << Util::Program.runprogram(%W(#{yt} --get-filename #{url}), parse_output: true)
    end
  end
  files.cleanup!
  files.map! { |i| Directory.join(i).to_s }
  files.map!(&:strip)
  files
end
FileNames = filenames.call.freeze
puts Mood.neutral { 'Filenames for downloaded videos:' }
# print "#{FileNames}\n" if Args.pretend
puts FileNames.inspect if Args.pretend

unless Args.playlist || Args.no_blacklist
  filenames = FileNames.dup
  n = Directory + 'no-playlist.txt'
  n.open('a') do |x|
    filenames.each do |i|
      puts Mood.happy { "Writing #{i} to #{n}}" } unless Args.pretend
      x.write(i) unless Args.pretend
    end
  end
  puts Mood.neutral { 'File names to put on the playlist blacklist:' } if Args.pretend
  filenames.each { |i| puts i } if Args.pretend
end

Util::FindApp.which('youtube-dl') do |yt|
  yt.freeze
  raise "Couldn't find youtube-dl" unless yt
  raise 'youtube-dl is not executable' unless yt && File.executable?(yt)
  outdir = Directory.to_s.freeze
  archdir = Directory.parent.parent.freeze if Args.subdirectory && outdir.include?('/data/Videos/Youtube') && Args.datesubdir

  archive =
    case
    when Args.archive
      puts Mood.neutral { 'Archive from command line' } if Args.pretend
      Args.archive + 'downloaded.txt'
    when Args.datesubdir && archdir
      puts Mood.neutral { 'Archive in subdirectory parent' } if Args.pretend
      archdir + 'downloaded.txt'
    when Args.datesubdir && outdir.include?('/data/Videos/Youtube')
      puts Mood.neutral { 'Archive in parent directory' } if Args.pretend
      Directory.parent + 'downloaded.txt'
    else
      puts Mood.neutral { 'Archive in download directory' } if Args.pretend
      Directory + 'downloaded.txt'
    end
  archive.freeze

  puts Mood.neutral { archive } if Args.pretend
  ytdl = %W(#{yt})
  ytdl << %W(--download-archive #{archive}) unless Args.force
  ytdl << %w(--merge-output-format webm) if Args.webm
  ytdl << '-k' if Args.keep_split
  ytdl << %w(--external-downloader ffmpeg --external-downloader-args -hide_banner --hls-prefer-ffmpeg) if Args.ffmpegdl
  ytdl << Urls
  ytdl.cleanup!(unique: false)
  ytdl.freeze

  Util::Program.runprogram(ytdl, workdir: outdir) unless Args.pretend || Args.no_download
  puts ytdl.inspect if Args.pretend && !Urls.nil? && !Urls.empty? && !Args.no_download
end

files = lambda do
  out = Directory.find.to_a
  puts Mood.neutral('Step 1:') if Args.pretend
  # print "#{out}\n" if Args.pretend
  puts out.inspect if Args.pretend
  puts Mood.neutral('No files found in this directory, will not do any statistics calculation, muxing, or playlist creation/modification.') if out.nil? || out.empty?
  out.keep_if(&:file?)
end

Files = files.call.freeze
exit if Files.nil? || Files.empty?

def genstatsfl(mkv)
  whitelist = %w(video/webm video/x-matroska audio/x-matroska).freeze
  mkv.keep_if do |file|
    file.freeze
    magic = FileMagic.new(:mime_type)
    whitelist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2 (stats):') if Args.pretend
  # print "#{mkv}\n" if Args.pretend
  puts mkv.inspect if Args.pretend
  mkv.delete_if do |file|
    file.freeze
    jsondata = VideoInfo.probe(file)
    jsondata.freeze unless frozen?
    jsondata.dig(:streams, 0, :tags, :BPS)
  end
  mkv.freeze
  puts Mood.neutral('Step 3 (stats):') if Args.pretend
  # print "#{mkv}\n" if Args.pretend
  puts mkv.inspect if Args.pretend
  puts Mood.neutral('No matroska files to calculate statistics for.') if mkv.nil? || mkv.empty?
  mkv
end

def genstats(filelist)
  Util::FindApp.which('mkvpropedit') do |mpe|
    mpe.freeze
    raise "Couldn't find mkvpropedit" unless mpe
    raise 'mkvpropedit is not executable' unless mpe && File.executable?(mpe)
    if filelist.respond_to?(:each) && filelist.respond_to?(:empty?) && !filelist.empty?
      filelist.each do |file|
        puts Mood.happy { "Adding statistic tags to #{file}" }
        cmd = %W(#{mpe} --add-track-statistics-tags #{file}).freeze
        begin
          Util::Program.runprogram(cmd) unless Args.pretend
          # print "#{cmd}\n" if Args.pretend
          puts cmd.inspect if Args.pretend
        rescue Subprocess::NonZeroExit => e
          puts e.message
          next
        end
      end
    end
  end
end

genstats(genstatsfl(Files.dup)) if Args.stats

def genmuxfl(muxfiles)
  magic = FileMagic.new(:mime_type)
  whitelist = %w(video/x-flv video/mp4 audio/x-m4a video/mp2t video/3gpp video/quicktime video/x-msvideo video/x-ms-wmv video/3gpp2 audio/x-wav)
  whitelist += %w(audio/wave video/dvd video/mpeg application/vnd.rn-realmedia-vbr audio/vnd.rn-realaudio audio/x-realaudio)
  whitelist.freeze
  blacklist = %w(video/webm video/x-matroska audio/x-matroska).freeze
  muxfiles.delete_if do |file|
    blacklist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2 (mux):') if Args.pretend
  # print "#{muxfiles}\n" if Args.pretend
  puts muxfiles.inspect if Args.pretend

  muxfiles.keep_if do |file|
    whitelist.include?(magic.file(file.to_s))
  end
  muxfiles.freeze

  puts Mood.neutral('Step 3 (mux):') if Args.pretend
  # print "#{muxfiles}\n" if Args.pretend
  puts muxfiles.inspect if Args.pretend
  muxfiles
end

def muxfiles(filelist)
  Util::FindApp.which('mkvmerge') do |mkvm|
    mkvm.freeze
    raise "Couldn't find mkvmerge" unless mkvm
    raise 'mkvmerge is not executable' unless mkvm && File.executable?(mkvm)

    config =
      case
      when Args.config.exist?
        configfile = Args.config.open
        confighash = JSON.parse(configfile.read)
        confighash = Util.recursive_symbolize_keys(confighash)
        configfile.close
        # print "#{confighash}\n" if Args.pretend && confighash
        puts confighash.inspect if Args.pretend && confighash
        confighash
      end
    config.freeze

    if filelist.respond_to?(:each) && filelist.respond_to?(:empty?) && !filelist.empty?
      filelist.each do |file|
        file.freeze
        out = Directory + file.basename.sub_ext('.mkv')
        cmd = config[:mkvmerge] ? %W(#{mkvm} #{config[:mkvmerge]} -o #{out} = #{file}) : %W(#{Util::FindApp.which(mkvmerge)} -o #{out} = #{file})
        cmd.cleanup!(unique: false)
        cmd.freeze
        # print "#{cmd}\n" if Args.pretend
        puts cmd.inspect if Args.pretend

        begin
          Util::Program.runprogram(cmd) unless Args.pretend
        rescue Subprocess::NonZeroExit => e
          puts e.message
          next
        else
          file.delete unless Args.pretend || Args.keep_original
        end
      end
    end
  end
end

muxfiles(genmuxfl(Files.dup)) if Args.mux

def genplaylisthash(filename, rootdir = '/data/Videos')
  jsondata = VideoInfo.probe(filename)
  filepath = Pathname.new(filename)
  rootpath = Pathname.new(rootdir)

  out = { location: URI.escape('file:///z:/'.dup + filepath.realpath.relative_path_from(rootpath).to_s).gsub("'", %q(\\')) } # rubocop:disable Style/UnneededPercentQ

  if jsondata.dig(:format, :tags)
    out[:title] = jsondata[:format][:tags][:title].gsub("'", %q(\\')) if jsondata.dig(:format, :tags, :title) # rubocop:disable Style/UnneededPercentQ
    out[:annotation] = CGI.escapeHTML(jsondata[:format][:tags][:DESCRIPTION]).gsub("'", '&apos;') if jsondata.dig(:format, :tags, :DESCRIPTION)
    out[:creator] = jsondata[:format][:tags][:ARTIST].gsub("'", %q(\\')) if jsondata.dig(:format, :tags, :ARTIST) # rubocop:disable Style/UnneededPercentQ
    out[:duration] = jsondata[:format][:duration].to_f.round.to_s if jsondata.dig(:format, :duration)
  end

  out
end

def genplaylist(files, out)
  tracklist = nil
  playlist = nil
  xspf = nil

  tracklist = XSPF::Tracklist.new unless tracklist.instance_of?(XSPF::Tracklist)
  if out.respond_to?(:exist?) && out.exist? && !Args.resetplaylist
    o = File.new(out.to_s)
    xspf = XSPF.new(o)
    playlist = xspf.playlist
    tracklist = playlist.tracklist
    o.close
  end

  files.each do |file|
    puts Mood.happy { "Adding #{file} to playlist" }
    track = file.to_s.include?('/data/Videos') ? XSPF::Track.new(genplaylisthash(file)) : XSPF::Track.new(genplaylisthash(file, Directory.to_s))
    tracklist << track
  end

  playlist = XSPF::Playlist.new(tracklist: tracklist) unless playlist.instance_of?(XSPF::Playlist)
  xspf = XSPF.new(playlist: playlist) unless xspf.instance_of?(XSPF)

  puts Mood.happy { "Creating Directory #{out.dirname}" } unless Args.pretend || out.dirname.exist?
  out.dirname.mkpath unless Args.pretend

  unless Args.pretend
    File.open(out.to_s, 'w') do |f|
      puts Mood.happy { "Writing playlist to #{out}" }
      f.write(xspf.to_xml)
    end
  end
  puts Mood.neutral { 'Playlist XML Content:' }
  puts xspf.to_xml if Args.pretend
end

def genplfilelist(filelist)
  outpath =
    case
    when Args.playlistpath
      Args.playlistpath
    when Directory.to_s.include?('/data/Videos/Youtube') && Args.subdirectory
      Pathname.new("/data/Videos/Youtube/Playlists/#{Args.subdirectory}/#{Args.date}.xspf")
    when Directory.to_s.include?('/data/Videos/Youtube') && !Args.subdirectory
      Pathname.new("/data/Videos/Youtube/Playlists/#{Args.date}.xspf")
    else
      Pathname.new("#{Directory}/Playlists/#{Args.date}.xspf")
    end

  whitelist = %w(video/x-flv video/mp4 audio/x-m4a video/mp2t video/3gpp video/quicktime video/x-msvideo video/x-ms-wmv video/3gpp2 audio/x-wav)
  whitelist += %w(audio/wave video/dvd video/mpeg application/vnd.rn-realmedia-vbr audio/vnd.rn-realaudio audio/x-realaudio)
  whitelist += %w(video/webm video/x-matroska audio/x-matroska)
  whitelist.freeze
  magic = FileMagic.new(:mime_type)

  existing = []
  blacklist = Directory.join('no-playlist.txt').readlines if Directory.join('no-playlist.txt').file?
  if outpath.exist? && !Args.resetplaylist
    o = File.new(outpath.to_s)
    xspf = XSPF.new(o)
    playlist = xspf.playlist
    tracklist = playlist.tracklist
    existing = tracklist.tracks
    existing.map!(&:location) if existing.respond_to?(:map!) && !existing.empty?
    # puts existing
    o.close
  end

  # tracklist = XSPF::Tracklist.new unless tracklist.instance_of?(XSPF::Tracklist)
  # filelist.keep_if { |i| i.to_s.include?(Args.subdirectory) } if Args.subdirectory
  filelist.keep_if { |i| i.dirname.to_s == Directory.to_s }
  unless existing.empty? || Args.resetplaylist
    filelist.delete_if do |i|
      b = existing.to_s.include?(URI.escape(i.relative_path_from(Pathname.new('/data/Videos')).to_s)) if Directory.to_s.include?('/data/Videos')
      b = existing.to_s.include?(URI.escape(i.relative_path_from(Directory).to_s)) unless Directory.to_s.include?('/data/Videos')
      # puts Mood.neutral { "Removing #{i} from file list" } if b
      b
    end
  end
  unless (blacklist && blacklist.respond_to?(:empty?) && blacklist.empty?) || Args.resetplaylist
    filelist.delete_if { |i| blacklist.to_s.include?(i.to_s) }
  end
  filelist.keep_if do |file|
    whitelist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral { 'No files to add to the playlist' } if filelist.empty?
  puts filelist if Args.pretend
  puts outpath if Args.pretend
  out = [filelist, outpath]
  puts out if Args.pretend
  out
end

if XSPF_Exists && Args.playlist
  filelist, outpath = genplfilelist(Files.dup)
  genplaylist(filelist, outpath) unless filelist.empty?
end
