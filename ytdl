#!/usr/bin/env ruby
require 'optparse'
require 'subprocess'
require 'pathname'
require 'filemagic'
require 'uri'
require 'json'

require_relative 'andyrb/videoinfo'
require_relative 'andyrb/mood'
require_relative 'andyrb/util'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.date = Time.now.strftime("%Y%m%d") # rubocop:disable Style/StringLiterals, Lint/UnneededDisable
    options.directory = Pathname.new('/data/Videos/Youtube')
    options.subdirectory = nil
    options.no_date = false
    options.force = false
    options.pretend = false
    options.no_stats = false
    options.archive = nil
    options.mkv_only = false
    options.no_mux = false
    options.config = Pathname.new(Dir.home) + '.config/convertmkv.json'
    options.keep_original = false
    options.keep_split = false
    options.ffmpegdl = false

    optparse = OptionParser.new do |opts|
      opts.on('-d', '--directory [DIRECTORY]', 'Name of the directory to download to') { |dir| options.directory = Pathname.new(dir) }
      opts.on('-a', '--archive [DIRECTORY]', 'Directory for the downloaded video list') { |dir| options.archive = Pathname.new(dir) }
      opts.on('-s', '--subdirectory [SUBDIRECTORY]', 'Optional subdirectory to tack on the end (only used if directory is set to the default)') { |dir| options.subdirectory = dir.to_s }
      opts.on('-n', '--no-date', "Don't create a subdirectory with the date (only needed if directory is set to the default)") { options.no_date = true }
      opts.on('-f', '--force', "Don't add the url(s) to the list of succesfully downloaded videos or read from said list.") { options.force = true }
      opts.on('--pretend', '-p', "Don't actually run youtube-dl or mkvpropedit") { options.pretend = true } # Mostly for testing code that doesn't rely on the programs actually running.
      opts.on('--mkv-only', "Don't run youtube-dl but run mkvpropedit.") { options.mkv_only = true }
      opts.on('--no-stats', "Don't calculate statistics for MKV files.") { options.no_stats = true }
      # opts.on('--no-mux', '-nm', "Don't mux non-mkv files") { options.no_mux = true }
      opts.on('--convertmkv-config', 'Location for the convertmkv configuration file.') { |c| options.config = c } # Reusing the convertmkv config file since the options used are the same.
      opts.on('--keep-original', '-k', 'Keep the original file if muxing non-mkv files.') { options.keep_original = true }
      opts.on('--keep-split', '-ks', 'Keep the original split download files (if there are any)') do
        options.keep_split = true
        options.no_mux = true
      end
      opts.on('--ffmpeg-download', 'Download using ffmpeg (hoping this will fix certain video downloads)') { options.ffmpegdl = true }
    end
    optparse.parse!(args)
    options
  end
end
ARGV.compact! if ARGV.respond_to?(:compact!)
ARGV.flatten! if ARGV.respond_to?(:flatten!)
ARGV.uniq! if ARGV.respond_to?(:uniq!)
Args = Options.parse(ARGV)
puts Args if Args.pretend

Urls = ARGV
Urls.keep_if { |url| url.is_a?(String) }
Urls.keep_if { |url| url =~ /\A#{URI.regexp(%w(http https))}\z/ }
print "#{Urls}\n" if Args.pretend

raise 'No URLs specified (or code is bugged)' if (Urls.nil? || Urls.empty?) && !Args.pretend
raise 'Somehow, Args.directory is nil' if Args.directory.nil?
raise 'Somehow, Args.directory is empty' if Args.directory.respond_to?(:empty?) && Args.directory.empty?
raise 'Somehow, Args.directory is not a Pathname' unless Args.directory.is_a?(Pathname)

Args.directory &&= Args.directory + Args.date if Args.directory.to_s == '/data/Videos/Youtube' && !Args.no_date

Args.directory &&= Args.directory + Args.subdirectory if Args.subdirectory && Args.subdirectory.is_a?(String) && Args.directory.to_s.include?('/data/Videos/Youtube')
puts Mood.neutral { Args.directory } if Args.pretend

case
when Args.directory.exist? && !Args.directory.directory?
  raise "#{Args.directory} exists but is not a directory."
when !Args.directory.exist?
  puts Mood.happy { "Creating Directory #{Args.directory}" }
  Args.directory.mkpath
end
Dir.chdir(Args.directory.to_s)
Util::FindApp.which('youtube-dl') do |yt|
  raise "Couldn't find youtube-dl" unless yt
  raise 'youtube-dl is not executable' unless yt && File.executable?(yt)

  # archdir = Args.directory.to_s if Args.subdirectory && Args.directory.to_s.include?('/data/Videos/Youtube')
  # archdir[%r{/#{Args.subdirectory}}] = '' if archdir
  # archdir = Pathname.new(archdir) if archdir
  archdir = Args.directory.parent.parent if Args.subdirectory && Args.directory.to_s.include?('/data/Videos/Youtube') && !Args.no_date

  archive =
    case
    when Args.archive
      puts Mood.neutral { 'Archive from command line' } if Args.pretend
      Args.archive + 'downloaded.txt'
    when !Args.no_date && archdir
      puts Mood.neutral { 'Archive in subdirectory parent' } if Args.pretend
      archdir + 'downloaded.txt'
    when !Args.no_date && Args.directory.to_s.include?('/data/Videos/Youtube')
      puts Mood.neutral { 'Archive in parent directory' } if Args.pretend
      Args.directory.parent + 'downloaded.txt'
    else
      puts Mood.neutral { 'Archive in download directory' } if Args.pretend
      Args.directory + 'downloaded.txt'
    end
  puts Mood.neutral { archive } if Args.pretend
  ytdl = %W(#{yt})
  ytdl += %W(--download-archive #{archive}) unless Args.force
  ytdl += '-k' if Args.keep_split
  ytdl += %w(--external-downloader ffmpeg --external-downloader-args -hide_banner) if Args.ffmpegdl
  ytdl += Urls

  Util::Program.runprogram(ytdl) unless Args.pretend || Args.mkv_only
  print "#{ytdl}\n" if Args.pretend && !Urls.nil? && !Urls.empty? && !Args.mkv_only
end

Files = Args.directory.find.to_a
Files.keep_if(&:file?)

puts Mood.neutral('Step 1:') if Args.pretend
print "#{Files}\n" if Args.pretend
puts Mood.neutral('No files found in this directory, will not do any statistics calculation or muxing.') if Files.nil? || Files.empty?
exit if Files.nil? || Files.empty?

case
when !Args.no_stats
  mkv = Files.dup
  mkv.keep_if do |file|
    magic = FileMagic.new(:mime_type)
    whitelist = %w(video/webm video/x-matroska audio/x-matroska)
    whitelist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2:') if Args.pretend
  print "#{mkv}\n" if Args.pretend
  mkv.delete_if do |file|
    json = Util.recursive_symbolize_keys(GenerateVideoInfo.probe(file))
    case
    when json.respond_to?(:dig)
      json.dig(:streams, 0, :tags, :BPS)
    when !json.respond_to?(:dig)
      true if json[:streams][0] && json[:streams][0][:tags] && json[:streams][0][:tags][:BPS]
      false unless json[:streams][0] && json[:streams][0][:tags] && json[:streams][0][:tags][:BPS]
    end
  end
  puts Mood.neutral('Step 3:') if Args.pretend
  print "#{mkv}\n" if Args.pretend
  puts Mood.neutral('No matroska files to calculate statistics for.') if mkv.nil? || mkv.empty?
  exit if mkv.nil? || mkv.empty?

  Util::FindApp.which('mkvpropedit') do |mpe|
    raise "Couldn't find mkvpropedit" unless mpe
    raise 'mkvpropedit is not executable' unless mpe && File.executable?(mpe)
    mkv.each do |file|
      puts Mood.happy("Adding statistic tags to #{file}")
      cmd = %W(#{mpe} --add-track-statistics-tags #{file})
      Util::Program.runprogram(cmd) unless Args.pretend
      print "#{cmd}\n" if Args.pretend
    end
  end
end
=begin
case
when !Args.no_mux
  muxfiles = Files.dup
  magic = FileMagic.new(:mime_type)
  muxfiles.delete_if do |file|
    blacklist = %w(video/webm video/x-matroska audio/x-matroska)
    blacklist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 2:') if Args.pretend
  print "#{muxfiles}\n" if Args.pretend

  muxfiles.keep_if do |file|
    whitelist = %w(video/x-flv video/mp4 video/mp2t video/3gpp video/quicktime video/x-msvideo video/x-ms-wmv video/3gpp2 audio/x-wav)
    whitelist += %w(audio/wave video/dvd video/mpeg application/vnd.rn-realmedia-vbr audio/vnd.rn-realaudio audio/x-realaudio)
    whitelist.include?(magic.file(file.to_s))
  end
  puts Mood.neutral('Step 3:') if Args.pretend
  print "#{muxfiles}\n" if Args.pretend

  exit if muxfiles.nil? || muxfiles.empty?
  Util::FindApp.which('mkvmerge') do |mkvm|
    raise "Couldn't find mkvmerge" unless mkvm
    raise 'mkvmerge is not executable' unless mkvm && File.executable?(mkvm)
    config =
      case
      when Args.config.exist?
        configfile = Args.config.open
        confighash = JSON.parse(configfile.read)
        confighash = Util.recursive_symbolize_keys(config)
        configfile.close
        print "#{confighash}\n" if Args.pretend && config
        confighash
      end
    muxfiles.each do |file|
      out = Args.directory + file.basename.sub_ext('.mkv')
      cmd = %W(#{mkvm} #{config[:mkvmerge]} -o #{out} = #{file})
      cmd.flatten!
      cmd.compact!
      print "#{cmd}\n" if Args.pretend

      begin
        Util::Program.runprogram(cmd) unless Args.pretend
      rescue Subprocess::NonZeroExit
        next
      else
        file.delete unless Args.pretend || Args.keep_original
      end
    end
  end
end
=end
