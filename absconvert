#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pathname'
require 'optparse'
require 'json'
require 'shellwords'
require 'subprocess'
require 'data_mapper'
begin
  require 'power_p'
rescue LoadError
  nil
end

require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/core/sort'
require_relative 'andyrb/core/monkeypatch'
require_relative 'andyrb/util/program'
require_relative 'andyrb/util/recursive_symbolize_keys'
require_relative 'andyrb/absconvert'
require_relative 'andyrb/videoinfo/database'

# Array.private_method_defined?(:include) ? Array.send(:include, AndyCore::Aray::Cleanup) : Array.include(AndyCore::Array::Cleanup)
# Array.private_method_defined?(:include) ? Array.send(:include, AndyCore::Aray::NatSort) : Array.include(AndyCore::Array::NatSort)
AndyCore.monkeypatch(Array, AndyCore::Array::Cleanup)
AndyCore.monkeypatch(Array, AndyCore::Array::NatSort)

opts = ABSConvert::Options.new(ARGV.dup)
opts.parse_args!
opts.parse_files!
opts.parse_config!
p opts if opts[:debug]
ffmpeg = Util::FindApp.which('ffmpeg')
mkvpropedit = Util::FindApp.which('mkvpropedit')

DataMapper.setup(:default, "sqlite:#{opts[:db].realpath}")
DataMapper::Logger.new($stdout, :debug) if opts[:verbose] || opts[:debug]
Bitrates = opts[:videobitrate] || opts[:audiobitrate] ? { videobitrate: opts[:videobitrate], audiobitrate: opts[:audiobitrate] } : nil
Framerate = opts[:framerate] ? opts[:framerate] : nil
opts.files.each do |i|
  metadata = ABSConvert::Metadata.new(i, opts[:db], verbose: opts[:verbose], bitrate: Bitrates, framerate: Framerate, novideo: opts[:novideo])
  filepath = Pathname.new(i)
  # outpath = Pathname.new(Args.outputdir.join(filepath.basename.sub_ext(outcon).to_s).to_s)
  outcon =
    case
    when opts[:container]
      ".#{opts[:container]}"
    when opts.config[:defaults][:container]
      ".#{opts.config[:defaults][:container]}"
    else
      '.mkv'
    end
  outcon.freeze
  outpath = opts[:outputdir].join(filepath.basename.sub_ext(outcon)).freeze
  logpath = filepath.sub_ext('-0.log').freeze if opts[:passes] == 2
  begin
    if opts[:passes] == 2
      pass1 = ABSConvert::CmdLine.new(i, args, opts.config, verbose: opts[:verbose], passnum: 1, passmax: 2)
      pass1.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      pass2 = ABSConvert::CmdLine.new(i, args, opts.config, verbose: opts[:verbose], passnum: 2, passmax: 2)
      pass2.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      Util::Program.runprogram(pass1.list)
      Util::Program.runprogram(pass2.list)
    elsif opts[:passes] == 1 && opts[:novideo]
      cmdline = ABSConvert::CmdLine.new(i, args, config, verbose: opts[:verbose], passnum: 1, passmax: 1)
      cmdline.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      Util::Program.runprogram(cmdline.list)
    end
  rescue Subprocess::NonZeroExit, Interrupt => e
    puts Mood.neutral('Removing unfinished output file.')
    outpath.delete if outpath.exist?
    raise e
  else
    Util::Program.runprogram(%W[#{mkvpropedit} --add-track-statistics-tags #{outpath}]) if opts[:stats] && outpath.exist? && !opts[:debug]

    if !opts[:converttest] && !opts[:debug].all?
      del = VideoInfo::Database::Videoinfo.all(filename: filepath.basename.to_s)
      deljson = VideoInfo::Database::Videojson.all(filename: filepath.basename.to_s)
      del.destroy
      deljson.destroy
    elsif opts[:converttest]
      puts Mood.happy('In convert testing mode, not deleting database entry')
    end
  ensure
    logpath.delete if [opts[:passes] == 2, logpath && logpath.exist?, !opts[:debug]].all?
  end

  ABSConvert.backup(file, opts[:backup].to_s) if opts[:backup] && !opts[:debug]
end
