#!/usr/bin/env python3.5
# pylint: disable=line-too-long
import argparse
import json
import locale
import pathlib
from collections import ChainMap
import shlex
import sys
import subprocess

try:
    import magic
except ImportError:
    pass

from andy.abs import ABS
from andy.util import Mood, Util

locale.setlocale(locale.LC_ALL, "en_US.utf-8")

args = argparse.ArgumentParser(description="A Basic Simple Converter: A Batch Conversion Frontend for ffmpeg", fromfile_prefix_chars="@", formatter_class=argparse.ArgumentDefaultsHelpFormatter)

video = args.add_argument_group(description="Video options:")
audio = args.add_argument_group(description="Audio Options:")
config = args.add_argument_group(description="Configuration/Testing options:")
fileargs = args.add_argument_group(description="Options for file manipulation:")

video.add_argument("--passes", "-p", choices=[1, 2], type=int, help="Number of video encoding passes.")
video.add_argument("--video-bitrate", "-vb", help="Bitrate for the video codec.")
video.add_argument("--video-codec", "-vc", help="Video codec to use.")
video.add_argument("--frame-rate", "-fr", dest="frame_rate", help="Frame Rate of the video for if ffmpeg has a problem detecting it automatically (especially helps with mpeg-1 files).")

audio.add_argument("--audio-bitrate", "-ab", help="Bitrate for the audio codec.")
audio.add_argument("--audio-codec", "-ac", help="Audio codec to use.")
audio.add_argument("--filter", "-f", nargs="*", help="Filter to be applied to the audio.")

config.add_argument("--database", "-db", help="Location of the video info database.")
config.add_argument("--convert-test", dest="converttest", action="store_true", help="Conversion test, doesn't delete entrys from database.")
config.add_argument("--config", "-c", default=str(pathlib.Path.home().joinpath(".config", "absconvert.json")), help="Location of the configuration file (JSON format).")
config.add_argument("--container", "-ct", help="Container format to put the video in.")
config.add_argument("--no-sort", "-ns", action="store_true", help="Don't sort the list of file(s) to be encoded.")
config.add_argument("--debug", "-d", action="store_true", help="Print variables and exit.")

fileargs.add_argument("--backup", "-b", help="Directory where files will be moved when encoded.")
fileargs.add_argument("--output-dir", "-o", dest="output", help="Directory to output the encoded file(s) to (defaults to previous directory unless you are in your home directory).")

args.add_argument("files", nargs="*", help="Files to encode.")

cmdline = vars(args.parse_args())


def filterfilelist(filelist):
    try:
        whitelist = ["video/x-flv", "video/mp4", "video/mp2t", "video/3gpp", "video/quicktime", "video/x-msvideo", "video/x-ms-wmv", "video/webm",
                     "video/x-matroska", "video/msvideo", "video/avi", "application/vnd.rm-realmedia", "audio/x-pn-realaudio", "audio/x-matroska",
                     "audio/ogg", "video/ogg", "audio/vorbis", "video/theora", "video/3gpp2", "audio/x-wav", "audio/wave", "video/dvd", "video/mpeg",
                     "application/vnd.rn-realmedia-vbr", "audio/vnd.rn-realaudio", "audio/x-realaudio"]

        with magic.Magic(flags=magic.MAGIC_MIME_TYPE) as m:
            for filename in filelist:
                filepath = pathlib.Path(filename)
                if m.id_filename(filename) in whitelist and filepath.is_file():
                    yield str(filepath)
    except NameError:
        whitelist = ['.webm', '.mkv', '.flv', '.vob', '.ogg', '.drc', '.avi', '.wmv', '.yuv', '.rm', '.rmvb', '.asf', '.mp4', '.m4v', '.mpg', '.mp2', '.mpeg',
                     '.mpe', '.mpv', '.3gp', '.3g2', '.mxf', '.roq', '.nsv', '.f4v', '.wav', '.ra', '.mka']
        for filename in filelist:
            filepath = pathlib.Path(filename)
            if filepath.suffix in whitelist and filepath.is_file():
                yield str(filepath)


def configdict():
    if ('config' not in cmdline or not cmdline["config"]) or not pathlib.Path(cmdline["config"]).exists():
        print("{} Could not find configuration file or one was not specified, generating one with default values.".format(Mood.neutral()))
        defaultconfig = {}

        defaultconfig["defaults"] = {}
        defaultconfig["defaults"]["video"] = "libvpx-vp9"
        defaultconfig["defaults"]["audio"] = "libopus"
        defaultconfig["defaults"]["container"] = "mkv"
        defaultconfig["defaults"]["passes"] = 2
        defaultconfig["defaults"]["audiofilter"] = ["aresample=async=1:min_comp=0.001:first_pts=0"]

        defaultconfig["codecs"] = {}
        defaultconfig["codecs"]["libvpx-vp9"] = ["-threads", "4", "-tile-columns", "6", "-frame-parallel", "1", "-speed", "1"]

        if not cmdline["debug"]:
            Util.genjson(defaultconfig, str(pathlib.Path.home().joinpath(".config", "absconvert.json")))

        return ChainMap(cmdline, defaultconfig)
    else:
        with open(cmdline["config"]) as jsonsource:
            config = json.loads(jsonsource.read())  # pylint: disable=W0621

        return ChainMap(cmdline, config)
options = configdict()

assert (isinstance(options, ChainMap)), "Options Variable must be a ChainMap"

if "backup" not in options:
    options["backup"] = None

if not options["output"]:
    if str(pathlib.Path.cwd()) == str(pathlib.Path.home()):
        options["output"] = str(pathlib.Path.home())
    else:
        options["output"] = str(pathlib.Path("..").resolve())

if "database" not in options or not options["database"]:
    options["database"] = None

absconvert = ABS(database=options["database"], debug=options["debug"], backup=options["backup"], output=options["output"], converttest=options["converttest"])

if options["container"]:
    options["container"] = ".{}".format(options["container"])
elif not options["container"]:
    options["container"] = ".{}".format(options["defaults"]["container"])

if not options["video_codec"]:
    options["video_codec"] = options["defaults"]["video"]

if not options["audio_codec"]:
    options["audio_codec"] = options["defaults"]["audio"]

if not options["filter"]:
    options["filter"] = options["defaults"]["audiofilter"]
elif cmdline["filter"] and isinstance(cmdline["filter"], str):
    options["filter"] = shlex.split(options["filter"])

if options["audio_codec"] in options["codecs"]:
    options["audiocodecopts"] = options["codecs"][options["audio_codec"]]
else:
    options["audiocodecopts"] = None

if options["video_codec"] in options["codecs"]:
    options["videocodecopts"] = options["codecs"][options["video_codec"]]
else:
    options["videocodecopts"] = None

if not options["passes"]:
    options["passes"] = options["defaults"]["passes"]

options["files"] = list(filterfilelist(options["files"]))

if len(options["files"]) is 0:
    print("{} There are no valid files to be encoded.".format(Mood.happy()))
    sys.exit(0)

if not options["no_sort"]:
    options["files"] = Util.sortentries(options["files"])

if "frame_rate" not in options:
    options["frame_rate"] = None

if options["debug"]:
    print(options)

for files in options["files"]:
    try:
        # Note to self, change these arguments from looking like keyword arguments to looking like positional arguments to reduce clutter.
        absconvert.convert(files, videocodec=options["video_codec"], videobitrate=options["video_bitrate"], audiocodec=options["audio_codec"],
                            audiofilteropts=options["filter"], passes=options["passes"], audiocodecopts=options["audiocodecopts"],  # noqa
                            audiobitrate=options["audio_bitrate"], videocodecopts=options["videocodecopts"], container=options["container"],  # noqa
                            framerate=options["frame_rate"])  # noqa
    except (KeyboardInterrupt, subprocess.CalledProcessError, ChildProcessError):
        break
