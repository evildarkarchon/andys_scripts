#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pathname'
require 'optparse'
require 'json'
require 'shellwords'
require 'subprocess'
require 'data_mapper'

require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/core/sort'
require_relative 'andyrb/core/monkeypatch'
require_relative 'andyrb/util/program'
require_relative 'andyrb/util/recursive_symbolize_keys'
require_relative 'andyrb/absconvert'
require_relative 'andyrb/videoinfo/database'

# Array.private_method_defined?(:include) ? Array.send(:include, AndyCore::Aray::Cleanup) : Array.include(AndyCore::Array::Cleanup)
# Array.private_method_defined?(:include) ? Array.send(:include, AndyCore::Aray::NatSort) : Array.include(AndyCore::Array::NatSort)
AndyCore.monkeypatch(Array, AndyCore::Array::Cleanup)
AndyCore.monkeypatch(Array, AndyCore::Array::NatSort)

opts = ABSConvert::Options.new(ARGV.dup)
opts.parse_args!
opts.parse_files!
opts.parse_config!
args = opts.args
ffmpeg = Util::FindApp.which('ffmpeg')
mkvpropedit = Util::FindApp.which('mkvpropedit')

DataMapper.setup(:default, "sqlite:#{args[:db].realpath}")
DataMapper::Logger.new($stdout, :debug) if [args[:verbose], args[:debug]].any?

opts.files.each do |i|
  metadata = ABSConvert::Metadata.new(i, args[:db], verbose: args[:verbose])
  metadata.bitrate!
  metadata.framerate! unless args[:novideo]
  filepath = Pathname.new(i)
  # outpath = Pathname.new(Args.outputdir.join(filepath.basename.sub_ext(outcon).to_s).to_s)
  outcon =
    case
    when args[:container]
      ".#{args[:container]}"
    when opts.config[:defaults][:container]
      ".#{opts.config[:defaults][:container]}"
    else
      '.mkv'
    end
  outcon.freeze
  outpath = args[:outputdir].join(filepath.basename.sub_ext(outcon)).freeze
  logpath = filepath.sub_ext('-0.log').freeze if args[:passes] == 2
  begin
    if args[:passes] == 2
      pass1 = ABSConvert::CmdLine.new(i, args, opts.config, verbose: args[:verbose], passnum: 1, passmax: 2)
      pass1.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      pass2 = ABSConvert::CmdLine.new(i, args, opts.config, verbose: args[:verbose], passnum: 2, passmax: 2)
      pass2.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      Util::Program.runprogram(pass1.list)
      Util::Program.runprogram(pass2.list)
    elsif [args[:passes] == 1, args[:novideo]].any?
      cmdline = ABSConvert::CmdLine.new(i, args, config, verbose: args[:verbose], passnum: 1, passmax: 1)
      cmdline.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      Util::Program.runprogram(cmdline.list)
    end
  rescue Subprocess::NonZeroExit, Interrupt => e
    puts Mood.sad('Removing unfinished output file.')
    outpath.delete if outpath.exist?
    raise e
  else
    Util::Program.runprogram(%W[#{mkvpropedit} --add-track-statistics-tags #{outpath}]) if [args[:stats], outpath.exist?, !args[:debug]].all?
    case
    when [!args[:converttest], !args[:debug]].all?
      del = VideoInfo::Database::Videoinfo.all(filename: filepath.basename.to_s)
      deljson = VideoInfo::Database::Videojson.all(filename: filepath.basename.to_s)
      del.destroy
      deljson.destroy
    when args[:converttest]
      puts Mood.happy('In convert testing mode, not deleting database entry')
    end
  ensure
    logpath.delete if [args[:passes] == 2, logpath && logpath.exist?, !args[:debug]].all?
  end

  ABSConvert.backup(file, args[:backup].to_s) if args[:backup]
end
