#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pathname'
require 'optparse'
require 'json'
require 'shellwords'
require 'subprocess'
require 'data_mapper'

require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/core/sort'
require_relative 'andyrb/util/program'
require_relative 'andyrb/util/recursive_symbolize_keys'
require_relative 'andyrb/absconvert'
require_relative 'andyrb/videoinfo/database'

Array.private_method_defined?(:include) ? Array.send(:include, AndyCore::Aray::Cleanup) : Array.include(AndyCore::Array::Cleanup)
Array.private_method_defined?(:include) ? Array.send(:include, AndyCore::Aray::NatSort) : Array.include(AndyCore::Array::NatSort)

class Options
  attr_reader :files, :options, :config, :paths

  def initialize(args)
    @options = {}
    @options[:novideo] = false
    @options[:noaudio] = false
    @options[:videocodec] = 'libvpx-vp9'
    @options[:audiocodec] = 'libopus'
    @options[:videocodecopts] = nil
    @options[:audiocodecopts] = nil
    @options[:videobitrate] = nil
    @options[:audiobitrate] = nil
    @options[:db] = Pathname.getwd.join('videoinfo.sqlite')
    @options[:audiofilter] = nil
    @options[:passes] = 2
    @options[:converttest] = false
    @options[:debug] = false
    @options[:config] = Pathname.new(Dir.home).join('.config/absconvert.json')
    @options[:sort] = true
    @options[:stats] = true
    @options[:container] = nil
    @options[:backup] = nil
    @options[:framerate] = nil
    @options[:outputdir] =
      case
      when Dir.pwd.include?('videoutiltest')
        Pathname.getwd
      when Dir.pwd == Dir.home
        Pathname.new(Dir.home)
      else
        Pathname.getwd.parent
      end
    @options[:verbose] = false
    @args = args
  end

  def parse_args!
    optparse = OptionParser.new do |opts|
      opts.on('--no-video', "Don't encode video stream") do
        @options[:novideo] = true
        @options[:videocodec] = nil
      end
      opts.on('--video-codec [codec]', 'Video codec to use to encode the video stream') do |i|
        novideo = %w[none None].any? { |a| a == i }
        @options[:novideo] = true if novideo
        @options[:videocodec] = !novideo ? i : nil
      end
      opts.on('--frame-rate [framerate]', '-f', 'Frame rate for the video stream') { |i| @options[:framerate] = i }
      opts.on('--video-bitrate [bitrate]', 'Bitrate for the video stream') { |i| @options[:videobitrate] = i }
      opts.on('--video-codec-opts [opts]', 'Options for the video codec') { |i| options[:videocodecopts] = i.shellsplit }
      opts.on('--passes [passes]', 'Number of passes for the video encoding') do |i|
        valid = [1, 2].any? { |a| a == i.to_i }
        @options[:passes] = i.to_i if valid
        @options[:passes] = 2 if i.to_i > 2
        @options[:passes] = 1 if i.to_i < 1
      end

      opts.on('--no-audio', "Don't encode audio stream") do
        @options[:noaudio] = true
        @options[:audiocodec] = nil
      end
      opts.on('--audio-codec [codec]', 'Audio codec to use to encode the audio stream') do |i|
        noaudio = %w[none None].any? { |a| a == i }
        @options[:audiocodec] = nil if noaudio
        @options[:noaudio] = true if noaudio
        @options[:audiocodec] = i unless noaudio
      end
      opts.on('--audio-bitrate [bitrate]', 'Bitrate for the audio stream') { |i| @options[:audiobitrate] = i }
      opts.on('--audio-codec-opts [opts]', 'Options for the audio codec') { |i| @options[:audiocodecopts] = i.shellsplit }
      opts.on('--audio-filter [filter]', 'Filter to be used on the output audio') { |i| @options[:audiofilter] = i }

      opts.on('--database [location]', 'Location of the videoinfo database') { |i| @options[:db] = i }
      opts.on('--convert-test', "Don't delete any videoinfo entries") { @options[:converttest] = true }
      opts.on('--config [path]', '-c [path]', 'Location of the configuration json file.') { |i| @options[:config] = Pathname.new(i) }
      opts.on('--container [ext]', 'Container to be used on the output file (do not include the dot).') { |i| @options[:container] = ".#{i}" }
      opts.on('--no-sort', "Don't sort the file list") { @options[:sort] = false }
      opts.on('--no-stats', "Don't calculate statistics tags for the output file.") { @options[:stats] = false }
      opts.on('--backup [dir]', '-b [dir]', 'Location of the backup directory (if any)') { |i| options[:backup] = Pathname.new(i) }
      opts.on('--output [dir]', '-o [dir]', 'Location of the output directory.') { |i| options[:outputdir] = i }
      opts.on('--verbose', '-v', 'Make the script a bit more chatty.') { @options[:verbose] = true }
      opts.on('--debug', '-d', 'Print variables and method states and exit') do
        @options[:debug] = true
        @options[:verbose] = true
      end
    end

    optparse.parse!(@args)

    vp9default = %w[-threads 4 -tile-columns 2 -frame-parallel 1 -speed 1]
    vp8default = %w[-threads 4 -speed 1]
    @options[:videocodecopts] = [@options[:videocodec] == 'libvpx-vp9', !@options[:videocodecopts]].all? ? vp9default : @options[:videocodecopts]
    @options[:videocodecopts] = [@options[:videocodec] == 'libvpx', !@options[:videocodecopts]].all? ? vp8default : @options[:videocodecopts]
  end

  def parse_files!
    @files = @args.dup
    @files.keep_if { |i| File.file?(i) } if @files.respond_to?(:keep_if)
    @paths = @files.map { |i| Pathname.new(i) }
  end

  def parse_config!
    @config = nil
    if options[:config].exist? # rubocop:disable Style/GuardClause
      options[:config].open do |cf|
        @config = JSON.parse(cf.read)
      end
      @config = Util.recursive_symbolize_keys(@config)
      puts config.inspect if @options[:debug] && @config
      @config.freeze
    end
  end
end

opts = Options.new(ARGV.dup)
opts.parse_args!
opts.parse_files!
opts.parse_config!
args = opts.options
ffmpeg = Util::FindApp.which('ffmpeg')
mkvpropedit = Util::FindApp.which('mkvpropedit')

DataMapper.setup(:default, "sqlite:#{args[:db].realpath}")
DataMapper::Logger.new($stdout, :debug) if [args[:verbose], args[:debug]].any?

opts.files.each do |i|
  metadata = ABSConvert::Metadata.new(i, args[:db], verbose: args[:verbose])
  metadata.bitrate!
  metadata.framerate! unless args[:novideo]
  filepath = Pathname.new(i)
  # outpath = Pathname.new(Args.outputdir.join(filepath.basename.sub_ext(outcon).to_s).to_s)
  outcon =
    case
    when args[:container]
      ".#{args[:container]}"
    when opts.config[:defaults][:container]
      ".#{opts.config[:defaults][:container]}"
    else
      '.mkv'
    end
  outcon.freeze
  outpath = args[:outputdir].join(filepath.basename.sub_ext(outcon)).freeze
  logpath = filepath.sub_ext('-0.log').freeze if args[:passes] == 2
  begin
    if args[:passes] == 2
      pass1 = ABSConvert::CmdLine.new(i, args, opts.config, verbose: args[:verbose], passnum: 1, passmax: 2)
      pass1.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      pass2 = ABSConvert::CmdLine.new(i, args, opts.config, verbose: args[:verbose], passnum: 2, passmax: 2)
      pass2.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      Util::Program.runprogram(pass1.list)
      Util::Program.runprogram(pass2.list)
    elsif [args[:passes] == 1, args[:novideo]].any?
      cmdline = ABSConvert::CmdLine.new(i, args, config, verbose: args[:verbose], passnum: 1, passmax: 1)
      cmdline.construct!(metadata.bitrates, metadata.frame_rate, ffmpeg)
      Util::Program.runprogram(cmdline.list)
    end
  rescue Subprocess::NonZeroExit, Interrupt => e
    puts Mood.sad('Removing unfinished output file.')
    outpath.delete if outpath.exist?
    raise e
  else
    Util::Program.runprogram(%W[#{mkvpropedit} --add-track-statistics-tags #{outpath}]) if [args[:stats], outpath.exist?, !args[:debug]].all?
    case
    when [!args[:converttest], !args[:debug]].all?
      del = VideoInfo::Database::Videoinfo.all(filename: filepath.basename.to_s)
      deljson = VideoInfo::Database::Videojson.all(filename: filepath.basename.to_s)
      del.destroy
      deljson.destroy
    when args[:converttest]
      puts Mood.happy('In convert testing mode, not deleting database entry')
    end
  ensure
    logpath.delete if [args[:passes] == 2, logpath && logpath.exist?, !args[:debug]].all?
  end

  ABSConvert.backup(file, args[:backup].to_s) if args[:backup]
end
