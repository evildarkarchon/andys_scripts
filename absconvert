#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'
require 'pathname'
require 'json'
require 'filemagic'
require 'subprocess'
require 'data_mapper'
require 'shellwords'

require_relative 'andyrb/mood'
require_relative 'andyrb/util'
require_relative 'andyrb/videoinfo_dm'

# rubocop:disable Style/CaseIndentation

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.videocodec = nil
    options.videocodecopts = nil
    options.videobitrate = nil
    options.framerate = nil
    options.passes = 2

    options.audiocodec = nil
    options.audiocodecopts = nil
    options.audiobitrate = nil
    options.audiofilter = nil

    options.db = Pathname.new('./videoinfo.sqlite')
    options.converttest = true
    options.config = Pathname.new(Dir.home).join('.config/absconvert.json')
    options.container = nil
    options.sort = true
    options.debug = false

    options.backup = nil
    options.converttest = false
    options.stats = true
    options.outputdir = case
    when Dir.pwd == Dir.home
      Pathname.new(Dir.home)
    else
      Pathname.new('..').realpath
    end # rubocop:disable Lint/EndAlignment
    options.verbose = false

    optparse = OptionParser.new do |opts|
      opts.on('--video-codec [codec]', 'Video codec for the output video.') do |vcodec|
        options.videocodec = case
        when vcodec == 'none'
          options.novideo = true
          nil
        else
          vcodec
        end # rubocop:disable Lint/EndAlignment
      end
      opts.on('--video-bitrate [bitrate]', 'Video bitrate for the output video.') { |vbitrate| options.videobitrate = vbitrate }
      opts.on('--passes [pass]', '-p [pass]', 'Number of video encoding passes.') do |passes|
        raise ArgumentError unless passes.respond_to?(:to_i)
        raise ArgumentError unless passes.between?(1, 2)
        options.passes = passes.to_i
      end
      opts.on('--video-codec-opts [opts]', 'Options to pass to the video codec') { |vco| options.videocodecopts = vco.shellsplit }
      opts.on('--frame-rate [rate]', '-f [rate]', 'Manually specify the frame rate (e.g. useful for MPEG2-PS files)') { |fr| options.framerate = fr.to_f if fr.respond_to?(:to_f) }
      opts.on('--no-video', 'Disable video channel') { |nv| options.videocodec = nil; options.novideo == nv } # rubocop:disable Style/Semicolon
      opts.on('--audio-bitrate [bitrate]', 'Bitrate of the output audio.') { |abitrate| options.audiobitrate = abitrate }
      opts.on('--audio-codec [codec]', 'Codec of the output audio.') do |acodec|
        options.audiocodec = case
        when acodec == 'none'
          options.noaudio = true
          nil
        else
          acodec
        end # rubocop:disable Lint/EndAlignment
      end
      opts.on('--audio-filter [filter]', 'Filter to be used for the output audio.') { |afilter| options.audiofilter = afilter }
      opts.on('--audio-codec-opts [opts]', 'Options to pass to the audio codec.') { |aco| options.audiocodecopts = aco.shellsplit }
      opts.on('--no-audio', 'Disable audio channel') { |na| options.audiocodec = nil; options.noaudio = na } # rubocop:disable Style/Semicolon
      opts.on('--database [location]', 'Location of the videoinfo database') { |db| optons.db = Pathname.new(db) }
      opts.on('--convert-test', "Don't delete any videoinfo entries.") { |ct| options.converttest = ct }
      opts.on('--config [path]', '-c [path]', 'Location of the configuration json file') { |config| options.config = Pathname.new(config) }
      opts.on('--container [extension]', 'Container to be used for the output file (the dot must be included).') { |ext| options.container = ext }
      opts.on('--no-sort', "Don't sort the file list.") { options.sort = false }
      opts.on('--no-stats', "Don't add statistics tags to the output file(s)") { options.stats = false }
      opts.on('--debug', '-d', 'Print variables and exit.') { options.debug = true }
      opts.on('--backup [dir]', '-b [dir]', 'Location of the backup directory (if any)') { |backup| options.backup = Pathname.new(backup) }
      opts.on('--output [dir]', '-o [dir]', 'Location of the output directory') { |output| options.outputdir = Pathname.new(output) }
      opts.on('--verbose', '-v', 'Make the script a bit more chatty.') { |v| options.verbose = v }
      opts.on('--convert-test', "Don't delete any database entries.") { |c| options.converttest = c }
    end
    optparse.parse!(args)
    options
  end
end

options = Options.parse(ARGV)
options.files = ARGV

DataMapper.setup(:default, "sqlite:#{options.db.realpath}")
DataMapper::Logger.new($stdout, :debug) if options.verbose
# vi = GenerateVideoInfo::Videoinfo.new

mkvpropedit = Util::FindApp.which('mkvpropedit')
ffmpeg = Util::FindApp.which('ffmpeg')

raise 'ffmpeg not found.' if ffmpeg.nil?

configfile = nil
config = nil
configfile = File.open options.config if File.exist? options.config
config = JSON.parse configfile.read if configfile.respond_to?(:read)
configfile.close if configfile.respond_to?(:close)
print "#{config}\n" if options.debug && config

def backup(source, backupdir)
  backuppath = Pathname.new(backupdir)
  sourcepath = Pathname.new(source)

  backup.mkpath unless backuppath.exist?
  raise 'Backup directory is a file.' if backuppath.exist? && backuppath.file?
  puts Mood.happy("Moving #{source} to #{backupdir}")
  sourcepath.rename(backuppath.join(sourcepath.basename)) if sourcepath.exist?
end

db = Class.new do
  define_method :bitrate do |file|
    path = Pathname.new(file).basename.to_s
    query = GenerateVideoInfo::Videoinfo.all(filename: path, fields: [:bitrate_0_raw, :type_0, :bitrate_1_raw, :type_1])

    bitrates = {}

    bitrates[:video] = query[0][:bitrate_0_raw] if query[0][:type_0] == 'video'
    bitrates[:video] = query[0][:bitrate_1_raw] if query[0][:type_1] == 'video'

    bitrates[:audio] = query[0][:bitrate_0_raw] if query[0][:type_0] == 'audio'
    bitrates[:audio] = query[0][:bitrate_1_raw] if query[0][:type_1] == 'audio'

    bitrates
  end
  define_method :frame_rate do |filename|
    filepath = Pathname.new(filename)
    dbinfo = GenerateVideoInfo::Videoinfo.all(filename: filepath.basename.to_s, fields: [:frame_rate])
    frame_rate = dbinfo[0][:frame_rate]
    frame_rate
  end
end
command = Class.new do
  define_method :list do |filename, passnum, passmax|
    filepath = Pathname.new(filename)
    bitrates = db.new.bitrate(filename)
    framerate = case
    when options.framerate
      options.framerate
    else
      db.new.frame_rate(filename)
    end # rubocop:disable Lint/EndAlignment
    vcodec = case
    when options.novideo
      '-vn'
    when config['defaults']['video']
      ['-c:v', config['defaults']['video']]
    when options.videocodec
      ['-c:v', options.videocodec]
    end # rubocop:disable Lint/EndAlignment

    unless options.novideo
      vbitrate = case
      when options.videobitrate
        ['-b:v', options.videobitrate.to_s]
      when bitrates[:video]
        ['-b:v', bitrates[:video].to_s]
      end # rubocop:disable Lint/EndAlignment
    end

    unless options.novideo
      vcodecopts = case
      when options.videocodecopts
        options.videocodecopts
      when config['codecs'][options.videocodec]
        config['codecs'][options.videocodec]
      end # rubocop:disable Lint/EndAlignment
    end

    acodec = case
    when passnum == 1, options.noaudio
      '-an'
    when !config['defaults']['audio']
      config['defaults']['audio']
    when options.audiocodec
      ['-c:a', options.audiocodec]
    else
      ['-c:a', 'libopus']
    end # rubocop:disable Lint/EndAlignment

    unless options.noaudio
      acodecopts = case
      when options.audiocodecopts
        options.audiocodecopts
      when config['codecs'][options.audiocodec]
        config['codecs'][options.audiocodec]
      end # rubocop:disable Lint/EndAlignment
    end

    unless options.noaudio
      abitrate = case
      when options.audiobitrate
        ['-b:a', options.audiobitrate.to_s]
      when bitrates[:audio]
        ['-b:a', bitrates[:audio].to_s]
      end # rubocop:disable Lint/EndAlignment
    end

    if !options.noaudio && options.audiofilter || !options.noaudio && config['defaults']['audiofilter']
      afilter = case
      when config['defaults']['audiofilter']
        ['-af', config['defaults']['audiofilter']]
      when options.audiofilter
        ['-af', options.audiofilter]
      end # rubocop:disable Lint/EndAlignment
    end
    outcon = case
    when options.container
      ".#{options.container}"
    when config['defaults']['container']
      ".#{config['defaults']['container']}"
    else
      '.mkv'
    end # rubocop:disable Lint/EndAlignment
    # print "#{passmax}\n"
    cmd = ['ffmpeg', '-i', filename]
    cmd << vcodec
    cmd << ['-pass', passnum.to_s] if passmax == 2
    cmd << vbitrate if vbitrate
    cmd << ['-pass', passnum.to_s, '-passlogfile', filepath.sub_ext('').to_s] if passmax == 2
    cmd << vcodecopts if vcodecopts
    cmd << ['-filter:v', "fps = #{framerate}"] if framerate
    cmd << acodec
    cmd << abitrate if abitrate
    cmd << acodecopts if acodecopts
    cmd << afilter if afilter
    cmd << ['-hide_banner', '-y']
    cmd << case
    when passnum == 1 && passmax == 2
      ['-f', 'matroska', '/dev/null']
    when passnum == 2 && passmax == 2, passmax = 1
      options.outputdir.join(filepath.basename.sub_ext(outcon).to_s).to_s
    end # rubocop:disable Lint/EndAlignment
    cmd.flatten!
  end
end
options.files.each do |file|
  outcon = case
  when options.container
    ".#{options.container}"
  when config['defaults']['container']
    ".#{config['defaults']['container']}"
  else
    '.mkv'
  end # rubocop:disable Lint/EndAlignment
  filepath = Pathname.new(file)
  outpath = Pathname.new(options.outputdir.join(filepath.basename.sub_ext(outcon).to_s).to_s)
  logpath = filepath.sub_ext('-0.log') if options.passes == 2
  if options.passes == 2
    cmdpass1 = command.new.list(file, 1, 2)
    cmdpass2 = command.new.list(file, 2, 2)
  elsif options.passes == 1
    cmd1pass = command.new.list(file, 1)
  end
  if options.debug
    print "#{cmdpass1}\n"
    print "#{cmdpass2}\n"
    print "#{cmd1pass}\n"
  end
  begin
    Util::Program.runprogram(cmdpass1) if options.passes == 2 && !options.debug
    Util::Program.runprogram(cmdpass2) if options.passes == 2 && !options.debug
    Util::Program.runprogram(cmd1pass) if options.passes == 1 && !options.debug
  rescue Subprocess::NonZeroExit => e
    puts Mood.sad('Removing unfinished output file.')
    outpath.delete if outpath.exist?
    raise e
  else
    Util::Program.runprogram([mkvpropedit, '--add-track-statistics-tags', outpath.to_s]) if options.stats
    unless options.converttest || options.debug
      del = GenerateVideoInfo::Videoinfo.all(filename: filepath.basename.to_s)
      deljson = GenerateVideoInfo::Videojson.all(filename: filepath.basename.to_s)
      del.destroy
      deljson.destroy
    end
    puts Mood.happy('In convert testing mode, not deleting database entry') if options.converttest
  ensure
    logpath.delete if options.passes == 2 && !options.debug
  end

  backup(file, options.backup.to_s) if options.backup
  # insert command-line generation, command invocation, backup and database cleanup code here.
end
