#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'
require 'pathname'
require 'find'

# require_relative 'andyrb/mood'
require_relative 'andyrb/util/hashfile'
require_relative 'andyrb/util/sort'
require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/videoinfo/database'
require_relative 'andyrb/videoinfo/filelist'
require_relative 'andyrb/videoinfo/genhash'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.reset_json = false
    options.reset_all = false
    options.verbose = false
    # options.del = false

    optparse = OptionParser.new do |opts|
      opts.on('--reset-json', 'Purges the JSON caches for all databases found.') { |j| options.reset_json = j }
      opts.on('--reset-all', 'Resets the entire database.') { |a| options.reset_all = a }
      opts.on('-v', '--verbose', 'Makes this script extra chatty') { |v| options.verbose = v }
      # opts.on('--delete', 'Only drop and recreate tables.') { |del| options.del = del }
    end
    optparse.parse!(args)
    options
  end
end
ARGV.cleanup! unless ARGV.nil? || ARGV.empty? || !ARGV.is_a?(Array)
Args = Options.parse(ARGV)
Args.directory = ARGV unless ARGV.nil? || ARGV.empty?
Args.directory = %w(/data/Private) if ARGV.nil? || ARGV.empty?
Args.directory.keep_if { |dirname| File.directory?(dirname) }

DataMapper::Model.raise_on_save_failure = true
DataMapper::Logger.new($stdout, :debug) if Args.verbose

directories = []
if Args.directory.respond_to?(:each)
  Args.directory.each do |i|
    directories << VideoInfo::Database.find(i, true)
    directories.cleanup!
  end
else
  directories << VideoInfo::Database.find(Args.directory, true)
  directories.cleanup!
end

directories = directories[0] if directories.is_a?(Array) && directories.length == 1
filelist = []
initlist = []

if directories.is_a?(Array) && directories.length > 1
  directories.each do |d|
    dbpath = Pathname.new(d).realpath
    dbpath = dbpath.dirname if dbpath.file?
    DataMapper.setup(:default, "sqlite:#{dbpath.join('videoinfo.sqlite')}")
    DataMapper.finalize
    # puts "Bad #{dbpath}" unless dbpath.join('videoinfo.sqlite').exist?
    VideoInfo::Database::Videoinfo.auto_migrate! unless Args.reset_json
    VideoInfo::Database::Videojson.auto_migrate! if Args.reset_json || Args.reset_all
=begin
    Find.find(dir) do |path|
      if File.basename(path)[0] == ?. # rubocop:disable Style/CharacterLiteral
        Find.prune # Don't look any further into this directory.
      else
        initpath = Pathname.new(path.to_s)
        initlist << initpath.to_s if initpath.file?
        next
      end
    end
=end
    initlist = dbpath.find.to_a
    initlist.keep_if(&:file?)
    initlist.map!(&:to_s)
    initlist.cleanup!

    filelist = Util.sort(VideoInfo.genfilelist(initlist))
    filelist.keep_if { |f| File.file?(f) }
  end
elsif (directories.is_a?(Array) && directories.length == 1) || directories.is_a?(String)
  # dbpath = Pathname.new(directories[0]) if directories.is_a?(Array)
  # dbpath = Pathname.new(directories).realpath unless directories.is_a?(Array)
  dbpath = directories.is_a?(Array) ? Pathname.new(directories[0]).realpath : Pathname.new(directories).realpath
  dbpath = dbpath.dirname if dbpath.file?
  # dir = dbpath.to_s

  DataMapper.setup(:default, "sqlite:#{dbpath.join('videoinfo.sqlite')}")
  DataMapper.finalize
  # puts "Bad #{dbpath}" unless dbpath.join('videoinfo.sqlite').exist?
  # VideoInfo::Database::Videoinfo.auto_migrate! unless Args.reset_json
  # VideoInfo::Database::Videojson.auto_migrate! if Args.reset_json || Args.reset_all
  case
  when Args.reset_json
    VideoInfo::Database::Videojson.auto_migrate!
  when !Args.reset_json && !Args.reset_all
    VideoInfo::Database::Videoinfo.auto_migrate!
  when Args.reset_all
    VideoInfo::Database::Videoinfo.auto_migrate!
    VideoInfo::Database::Videojson.auto_migrate!
  end

  # Find.find(dir) do |path|
  #   Find.prune if File.basename(path)[0].include?('.') # Don't look any further into this directory.
  #   file = File.file?(path)
  #   next unless file
  #   puts path if Args.debug
  #   initlist << path if file
  # end
  initlist = dbpath.find.to_a
  initlist.cleanup!
  initlist.keep_if(&:file?)
  initlist.map!(&:to_s)

  filelist = Util.sort(VideoInfo.genfilelist(initlist))
  # filelist.each do |i|
  #   filepath = Pathname.new(i)
  #   filelist.delete(i) unless filepath.file?
  #   puts 'Bad' unless filepath.file?
  # end
  # puts filelist
end

digests = Util.hashfile(filelist)

filelist.each do |file|
  filepath = Pathname.new(file)
  FileUtils.touch(file) unless filepath.file?

  DataMapper.setup(:default, "sqlite:#{filepath.dirname.join('videoinfo.sqlite')}") if filepath.file?
  DataMapper.setup(:default, "sqlite:#{filepath.join('videoinfo.sqlite')}") if filepath.directory?
  gvi = VideoInfo::Database::Data.new(filepath.dirname.join('videoinfo.sqlite').to_s, Args.verbose) if filepath.file?
  gvi = VideoInfo::Database::Data.new(filepath.join('videoinfo.sqlite').to_s, Args.verbose) if filepath.directory?
  insert = VideoInfo::Database::Videoinfo.new

  jsondata = gvi.json(file, Args.verbose)

  VideoInfo.genhash(file, jsondata, digests) do |h|
    begin
      puts Mood.happy { "Writing metadata for #{File.basename(file)}" }
      insert.attributes = h
      insert.save
    rescue DataMapper::SaveFailureError
      insert.errors.each { |e| puts e } if Args.verbose
    end
  end

  digests.delete(file)
end
