#!/usr/bin/env ruby
# frozen_string_literal: true

require 'ostruct'
require 'optparse'
require 'pathname'
require 'find'

# require_relative 'andyrb/mood'
require_relative 'andyrb/util/hashfile'
require_relative 'andyrb/util/sort'
require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/videoinfo/database'
require_relative 'andyrb/videoinfo/filelist'
require_relative 'andyrb/videoinfo/genhash'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.reset_json = false
    options.reset_all = false
    options.verbose = false
    # options.del = false

    optparse = OptionParser.new do |opts|
      opts.on('--reset-json', 'Purges the JSON caches for all databases found.') { |j| options.reset_json = j }
      opts.on('--reset-all', 'Resets the entire database.') { |a| options.reset_all = a }
      opts.on('-v', '--verbose', 'Makes this script extra chatty') { |v| options.verbose = v }
      # opts.on('--delete', 'Only drop and recreate tables.') { |del| options.del = del }
    end
    optparse.parse!(args)
    options
  end
end
args = lambda do
  out = nil
  out = ARGV.dup.cleanup! unless ARGV.nil? || ARGV.empty?
  out = Options.parse(out)
  outdir = out.nil? || out.empty? ? %w(/data/Private) : out
  outdir.keep_if { |d| File.directory?(d) } if outdir.respond_to?(:keep_if)
  [out.freeze, outdir.freeze]
end

# ARGV.cleanup! unless ARGV.nil? || ARGV.empty? || !ARGV.is_a?(Array)
# Args = Options.parse(ARGV)
# Directory = ARGV unless ARGV.nil? || ARGV.empty?
# Directory = %w(/data/Private) if ARGV.nil? || ARGV.empty?
# Directory.keep_if { |dirname| File.directory?(dirname) } if Directory.respond_to?(:keep_if)
# Args.freeze

Args, Directory = args.call

DataMapper::Model.raise_on_save_failure = true
DataMapper::Logger.new($stdout, :debug) if Args.verbose

directories = []
if Directory.respond_to?(:each)
  Directory.each do |i|
    directories = VideoInfo::Database.find(i, Args.verbose)
    # directories.cleanup!
    # puts 'directories 1:'
    # print "#{directories}\n"
  end
else
  directories = VideoInfo::Database.find(Directory, Args.verbose)
  # directories.cleanup!
  # puts 'directories 1:'
  # print "#{directories}\n"
end

filelist = []
initlist = []

if directories.respond_to?(:each)
  directories.each do |d|
    dbpath = Pathname.new(d).realpath
    dbpath = dbpath.dirname if dbpath.file?
    DataMapper.setup(:default, "sqlite:#{dbpath.join('videoinfo.sqlite')}")
    DataMapper.finalize
    # puts "Bad #{dbpath}" unless dbpath.join('videoinfo.sqlite').exist?
    VideoInfo::Database::Videoinfo.auto_migrate! unless Args.reset_json
    VideoInfo::Database::Videojson.auto_migrate! if Args.reset_json || Args.reset_all

    initlist << dbpath.find.to_a
    # puts 'directories 2m:'
    # print "#{initlist}\n"
    # puts
    initlist.cleanup!
    initlist.keep_if { |i| File.file?(i) }
    initlist.map!(&:to_s)

    filelist = Util.sort(VideoInfo.genfilelist(initlist))
    # puts 'directories 3m:'
    # print "#{filelist}\n"
    # puts
  end
else
  # dbpath = Pathname.new(directories[0]) if directories.is_a?(Array)
  # dbpath = Pathname.new(directories).realpath unless directories.is_a?(Array)
  dbpath = Pathname.new(directories).realpath
  dbpath = dbpath.dirname if dbpath.file?
  # dir = dbpath.to_s

  DataMapper.setup(:default, "sqlite:#{dbpath.join('videoinfo.sqlite')}")
  DataMapper.finalize
  # puts "Bad #{dbpath}" unless dbpath.join('videoinfo.sqlite').exist?
  # VideoInfo::Database::Videoinfo.auto_migrate! unless Args.reset_json
  # VideoInfo::Database::Videojson.auto_migrate! if Args.reset_json || Args.reset_all
  case
  when Args.reset_json
    VideoInfo::Database::Videojson.auto_migrate!
  when Args.reset_all
    VideoInfo::Database::Videoinfo.auto_migrate!
    VideoInfo::Database::Videojson.auto_migrate!
  else
    VideoInfo::Database::Videoinfo.auto_migrate!
  end

  # Find.find(dir) do |path|
  #   Find.prune if File.basename(path)[0].include?('.') # Don't look any further into this directory.
  #   file = File.file?(path)
  #   next unless file
  #   puts path if Args.debug
  #   initlist << path if file
  # end
  initlist = dbpath.find.to_a
  initlist.keep_if(&:file?)
  initlist.map!(&:to_s)
  initlist.cleanup!
  initlist.freeze
  # puts 'directories 2s:'
  # print "#{initlist}\n"
  # puts

  filelist = Util.sort(VideoInfo.genfilelist(initlist))
  filelist.freeze unless frozen?
  # puts 'directories 3s:'
  # print "#{filelist}\n"
  # puts

  # filelist.each do |i|
  #   filepath = Pathname.new(i)
  #   filelist.delete(i) unless filepath.file?
  #   puts 'Bad' unless filepath.file?
  # end
  # puts filelist
end

digests = Util.hashfile(filelist).freeze

filelist.each do |file|
  filepath = Pathname.new(file).freeze
  FileUtils.touch(file) unless filepath.file?

  DataMapper.setup(:default, "sqlite:#{filepath.dirname.join('videoinfo.sqlite')}") if filepath.file?
  DataMapper.setup(:default, "sqlite:#{filepath.join('videoinfo.sqlite')}") if filepath.directory?
  gvi = VideoInfo::Database::Data.new(filepath.dirname.join('videoinfo.sqlite').to_s, Args.verbose) if filepath.file?
  gvi = VideoInfo::Database::Data.new(filepath.join('videoinfo.sqlite').to_s, Args.verbose) if filepath.directory?
  insert = VideoInfo::Database::Videoinfo.new

  jsondata = gvi.json(file, Args.verbose)
  jsondata.freeze unless frozen?
  # print "#{jsondata}\n"
  # puts jsondata

  VideoInfo.genhash(file, jsondata, digests) do |h|
    begin
      puts(Mood.happy { "Writing metadata for #{File.basename(file)}" })
      insert.attributes = h
      insert.save
    rescue DataMapper::SaveFailureError
      insert.errors.each { |e| puts e } if Args.verbose
    end
  end

  digests.delete(file)
end
