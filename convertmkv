#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'
require 'pathname'
require 'fileutils'

require_relative 'andyrb/mood'
require_relative 'andyrb/util'
require_relative 'andyrb/videoinfo'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.db = Pathname.new('./videoinfo.sqlite')
    options.gvi = true
    options.sort = true
    options.ffmpeg = false
    options.output = Pathname.getwd
    options.outputdb = nil
    options.backup = nil
    options.combine = false
    options.debug = false

    optparse = OptionParser.new do |opts|
      opts.on('--database file', 'Database to read metadata from (if any).') { |db| options.db = Pathname.new(db) }
      opts.on('-f', '--ffmpeg', 'Use ffmpeg instead of mkvmerge. Note: ffmpeg hates mpeg2-ps files.') { |f| options.ffmpeg = f }
      opts.on('-c', '--combine', 'Run in concatenation mode.') { |c| options.combine = c }
      opts.on('--no-sort', "Don't sort the list of files to be muxed.") { options.sort = false }
      opts.on('--no-gvi', "Don't generate video info for the muxed files.") { options.gvi = false }
      opts.on('-o directory', '--output directory', 'Directory where the muxed files will be located. (defaults to current directory)') { |dir| options.output = Pathname.new(dir) }
      opts.on('-b directory', '--backup directory', 'Directory where the source files will be moved.') { |dir| options.backup = Pathname.new(dir) }
      opts.on('--output-database file', 'File name for the output videoinfo database (if any)') { |db| options.outputdb = Pathname.new(db) }
      opts.on('--debug', '-d', "Print what would be done, but don't actually do it") { |debug| options.debug = debug }
    end
    optparse.parse!(args)
    options
  end
end

options = Options.parse(ARGV)
options.db = options.db.realpath if options.db.exist? && options.gvi == true
options.files = Util::SortEntries.sort(ARGV) if options.sort == true
options.files = ARGV unless options.sort == true

mkvpropedit = Util::FindApp.which('mkvpropedit')
ffmpeg = Util::FindApp.which('ffmpeg')
mkvmerge = Util::FindApp.which('mkvmerge')

if ffmpeg.nil? && options.ffmpeg && !mkvmerge.nil?
  puts Mood.neutral('ffmpeg not found, using mkvmerge instead.')
  options.ffmpeg = false
end
if mkvmerge.nil? && !options.ffmpeg && !ffmpeg.nil?
  puts Mood.neutral('mkvmerge not found, using ffmpeg instead.')
  options.ffmpeg = true
end
raise 'Can not find mkvpropedit.' if mkvpropedit.nil? && options.ffmpeg
raise 'Can not find mkvmerge or ffmpeg.' if mkvmerge.nil? && ffmpeg.nil?

vi = nil
vi = VideoInfo::Database.new(options.db.to_s) if options.db.exist?
puts vi if options.debug == true
gvi = nil
gvi = VideoInfo::Generate.new(options.db.to_s) if options.db.exist? && options.gvi == true
gvi = VideoInfo::Generate.new(options.outputdb.to_s) if options.outputdb && options.gvi == true
puts gvi if options.debug == true

flat = Class.new do
  define_method :genvi do |filename|
    filepath = Pathname.new(filename).realpath
    outhash = Util::HashFile.genhash(filepath.to_s)
    puts Mood.happy("Extracting metadata from #{filepath}")
    jsondata = gvi.json(filename, options.debug)
    metadata = VideoInfo::Generate.hash(filename, jsondata, outhash)
    gvi.write(metadata, jsondata, options.debug)
  end

  define_method :ffmpegconcat do
    filelist = Tempfile.new('mkv', mode: 'a+')
    options.files.each do |file|
      dur = vi.read('select duration_raw from videoinfo where filename = ?', file) if vi
      filelist.write("file '#{file}'\n")
      filelist.write("duration #{dur}\n") if dur
    end
    Util::Program.runprogram([ffmpeg, '-f', 'concat', '-safe', '0', '-i', filelist.path, '-c', 'copy', '-hide_banner', '-y', options.output.to_s]) unless options.debug == true
    Util::Program.runprogram([mkvpropedit, '--add-track-statistics-tags', options.output.to_s]) unless options.debug
    genvi(options.output.to_s) if options.gvi
    puts filelist.read if options.debug == true
  end

  define_method :mkvmergeconcat do
    basecommand = [mkvmerge, '-o', options.output.to_s]
    filelist = options.files.join(' + ')
    filelist = filelist.split
    command = basecommand + filelist
    Util::Program.runprogram(command) unless options.debug == true
    genvi(options.output.to_s) if options.gvi == true
  end

  define_method :backup do |filename|
    if !options.backup.nil? && options.backup.directory?
      puts Mood.happy("Moving #{filename} to #{options.backup}")
      FileUtils.mv(filename, options.backup.to_s) unless options.debug
      vi.deletefileentry(filename) unless vi.nil? || options.debug
    end
  end
end

options.output.mkpath unless options.output.exist? || options.combine

if options.combine
  raise 'Output specified is not a file' if options.output.exist? && !options.output.file?
  flat.new.mkvmergeconcat unless options.ffmpeg && options.debug == false
  flat.new.ffmpegconcat if options.ffmpeg == true && options.debug == false
  options.files.each do |file|
    flat.new.backup(file)
  end
else
  raise 'Output specified is not a directory' unless options.output.directory?
  options.files.each do |file|
    filepath = Pathname.new(file)
    fileoutpath = options.output.join(filepath.sub_ext('.mkv').basename.to_s)
    puts Mood.happy("Muxing #{file} to a matroska file.")
    if options.ffmpeg
      Util::Program.runprogram([ffmpeg, '-i', filepath.realpath.to_s, '-c', 'copy', '-f', 'matroska', '-hide_banner', '-y', fileoutpath.to_s]) unless options.debug == true
      Util::Program.runprogram([mkvpropedit, '--add-track-statistics-tags', fileoutpath.to_s]) unless options.debug == true
    else
      Util::Program.runprogram([mkvmerge, '-o', fileoutpath.to_s, '=', file]) unless options.debug == true
    end
    flat.new.genvi(fileoutpath.to_s) if options.gvi && !file.include?('+')
    flat.new.backup(file) if options.backup
  end
end
