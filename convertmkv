#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'
require 'pathname'
require 'fileutils'
require 'data_mapper'
require 'json'
# require 'tmpdir'

require_relative 'andyrb/mood'
require_relative 'andyrb/util'
require_relative 'andyrb/videoinfo_dm'

class Options
  def self.parse(args)
    options = OpenStruct.new
    options.db = Pathname.new('./videoinfo.sqlite')
    options.gvi = true
    options.sort = true
    options.ffmpeg = false
    options.output = Pathname.getwd
    options.outputdb = nil
    options.backup = nil
    options.combine = false
    options.debug = false
    options.verbose = false
    options.config = '/home/evildarkarchon/.config/convertmkv.json'

    optparse = OptionParser.new do |opts|
      opts.on('--database file', 'Database to read metadata from (if any).') { |db| options.db = Pathname.new(db) }
      opts.on('-f', '--ffmpeg', 'Use ffmpeg instead of mkvmerge. Note: ffmpeg hates mpeg2-ps files.') { |f| options.ffmpeg = f }
      opts.on('-c', '--combine', 'Run in concatenation mode.') { |c| options.combine = c }
      opts.on('--no-sort', "Don't sort the list of files to be muxed.") { options.sort = false }
      opts.on('--no-gvi', "Don't generate video info for the muxed files.") { options.gvi = false }
      opts.on('-o directory', '--output directory', 'Directory where the muxed files will be located. (defaults to current directory)') { |dir| options.output = Pathname.new(dir) }
      opts.on('-b directory', '--backup directory', 'Directory where the source files will be moved.') { |dir| options.backup = Pathname.new(dir) }
      opts.on('--outputdb file', 'File name for the output videoinfo database (if any)') { |db| options.outputdb = Pathname.new(db) }
      opts.on('--debug', '-d', "Print what would be done, but don't actually do it") { |debug| options.debug = debug }
      opts.on('-v', '--verbose', 'Get a lot more chatty.') { |v| options.verbose = v }
      opts.on('--config file', 'Location of the configuration file') { |c| options.config = c }
    end
    optparse.parse!(args)
    options
  end
end

Args = Options.parse(ARGV)
Args.db = Args.db.realpath if Args.db.exist?
Args.outputdb = Args.db if Args.outputdb.nil? && Args.output.directory?
Args.outputdb = Args.db if Args.outputdb.nil? && !Args.output.exist?
Args.outputdb = Args.db if Args.outputdb && Args.outputdb == Args.output + '/' + 'videoinfo.sqlite' && !Args.output.parent.directory && Args.combine
Args.outputdb = Args.output.join('videoinfo.sqlite') if Args.outputdb.nil? && !Args.output.directory?(Args.output) && !Args.combine
puts Args.outputdb
FileUtils.touch(Args.db.to_s) unless Args.db.file?
FileUtils.touch(Args.outputdb.to_s) if Args.outputdb && !Args.outputdb.parent.directory? && !Args.outputdb.file?
Args.files = Util::SortEntries.sort(ARGV) if Args.sort
Args.files = ARGV unless Args.sort
print "#{Args.files}\n"
MkvPropEdit = Util::FindApp.which('mkvpropedit')
FFMPEG = Util::FindApp.which('ffmpeg')
MkvMerge = Util::FindApp.which('mkvmerge')

Args.ffmpeg = false if Args.combine
puts Mood.neutral 'ffmpeg concatenation mode has been disabled for the time being, reverting to mkvmerge.' if Args.combine && Args.ffmpeg

configfile = nil
configfile = File.open(Args.config) if File.exist? Args.config
Config = JSON.parse(configfile.read) if configfile.respond_to?(:read)
configfile.close if configfile.respond_to?(:close)

if FFMPEG.nil? && Args.ffmpeg && !MkvMerge.nil?
  puts Mood.neutral('ffmpeg not found, using mkvmerge instead.')
  Args.ffmpeg = false
end
if MkvMerge.nil? && !Args.ffmpeg && !FFMPEG.nil?
  puts Mood.neutral('mkvmerge not found, using ffmpeg instead.')
  Args.ffmpeg = true
end
raise 'Can not find mkvpropedit.' if MkvPropEdit.nil? && Args.ffmpeg
raise 'Can not find mkvmerge or ffmpeg.' if MkvMerge.nil? && FFMPEG.nil?

DataMapper::Model.raise_on_save_failure = true
DataMapper.setup(:default, "sqlite:#{Args.db.realpath}")
DataMapper.setup(:output, "sqlite:#{Args.outputdb.realpath}") if Args.outputdb
DataMapper::Logger.new($stdout, :debug) # if Args.debug || Args.verbose
# db = DataMapper.repository(:default).adapter
Vi = GenerateVideoInfo::Videoinfo.new
Gvi = GenerateVideoInfo::Data.new(Args.db.realpath, Args.verbose) if Args.gvi
DataMapper.finalize
begin
  DataMapper.auto_upgrade!
rescue DataObjects::SyntaxError
  DataMapper.auto_migrate!
end

class Convenience
  def initialize(filename)
    @filename = filename
  end

  def genvi
    filepath = Pathname.new(@filename).realpath
    insert = GenerateVideoInfo::Videoinfo.new
    outhash = Util.hashfile(filepath.realpath.to_s)
    print "#{outhash}\n"
    puts Mood.happy("Extracting metadata from #{filepath}")
    if Args.outputdb
      DataMapper.repository(:output) do
        GenerateVideoInfo::Videoinfo.storage_names[:output] = 'videoinfo'
        GenerateVideoInfo::Videojson.storage_names[:output] = 'videojson'
        begin
          GenerateVideoInfo::Videoinfo.auto_upgrade!
          GenerateVideoInfo::Videojson.auto_upgrade!
        rescue DataObjects::SyntaxError
          GenerateVideoInfo::Videoinfo.auto_migrate!
          GenerateVideoInfo::Videojson.auto_migrate!
        end
      end
    end
    jsondata = Gvi.json(@filename, Args.debug) unless Args.outputdb
    jsondata = DataMapper.repository(:output) { Gvi.json(@filename, Args.debug, :output) } if Args.outputdb
    GenerateVideoInfo.genhash(@filename, jsondata, outhash) do |h|
      begin
        puts Mood.happy("Writing metadata for #{File.basename(@filename)}")
        if !Args.outputdb
          insert.attributes = h
          insert.save
        else
          DataMapper.repository(:output) do
            GenerateVideoInfo::Videoinfo.storage_names[:output] = 'videoinfo'
            insert.attributes = h
            insert.save
          end
        end
      rescue DataMapper::SaveFailureError
        insert.errors.each { |e| puts e } if Args.verbose
      end
    end
  end

=begin
  def self.ffmpegconcat
    filelistname = File.join(Dir.pwd, 'mkvfilelist')
    FileUtils.touch(filelistname)
    filelist = File.open(filelistname, 'a+')
    filelist.write('ffconcat version 1.0')
    Args.files.each do |file|
      filepath = Pathname.new(file)
      relpath = filepath.relative_path_from(Pathname.pwd).to_s if filepath.realpath.parent != Pathname.pwd
      relpath = './' + filepath.basename.to_s
      query = GenerateVideoInfo::Videoinfo.all(filename: File.basename(file))
      dur = query[0][:duration_raw] unless query.nil?
      dur = nil if dur.respond_to?(:empty?) && dur.empty?
      # dur = db.select('select duration_raw from videoinfo where filename = ?', file)[0] if db
      filelist.write("file '#{relpath}'\n")
      filelist.write("duration #{dur}\n") if dur
    end
    cmd = [FFMPEG, '-f', 'concat', '-safe', '0', '-i', filelistname, '-c', 'copy', '-hide_banner', '-y', Args.output.to_s]
    begin
      Util::Program.runprogram(cmd) unless Args.debug
      Util::Program.runprogram([MkvPropEdit, '--add-track-statistics-tags', Args.output.to_s]) unless Args.debug
      genvi(Args.output.to_s) if Args.gvi
    ensure
      puts filelist.read if Args.debug || Args.verbose
      filelist.close
      # FileUtils.rm(filelistname)
    end
  end
=end

  def self.mkvmergeconcat
    basecommand = [MkvMerge, '-o', Args.output.to_s]
    filelist = Args.files.join(' + ')
    filelist = filelist.split
    command = basecommand + Config['mkvmerge'] + filelist
    command.flatten!
    command.compact!
    Util::Program.runprogram(command) unless Args.debug
    genvi(Args.output.to_s) if Args.gvi
  end

  def backup
    if !Args.backup.nil? && Args.backup.directory?
      puts Mood.happy("Moving #{@filename} to #{Args.backup}")
      FileUtils.mv(@filename, Args.backup.to_s) unless Args.debug
      unless Vi.nil? || Args.debug
        vientry = GenerateVideoInfo::Videoinfo.all(filename: @filename)
        vientry.destroy
      end
    end
  end
end

Args.output.mkpath unless Args.output.exist? || Args.combine

if Args.combine
  raise 'Output specified is not a file' if Args.output.exist? && !Args.output.file?
  Convenience.mkvmergeconcat unless Args.ffmpeg && Args.debug == false
  # Convenience.ffmpegconcat if Args.ffmpeg == true && Args.debug == false
  Args.files.each do |file|
    convenience = Convenience.new(file)
    convenience.backup
  end
else
  raise 'Output specified is not a directory' unless Args.output.directory?
  Args.files.each do |file|
    convenience = Convenience.new(file)
    filepath = Pathname.new(file)
    fileoutpath = Args.output.join(filepath.sub_ext('.mkv').basename.to_s)
    puts Mood.happy("Muxing #{file} to a matroska file.")
    if Args.ffmpeg
      longcmd = [FFMPEG, '-i', filepath.realpath.to_s, '-c', 'copy', '-f', 'matroska', '-hide_banner', '-y', fileoutpath.to_s]
      Util::Program.runprogram(longcmd) unless Args.debug
      Util::Program.runprogram([MkvPropEdit, '--add-track-statistics-tags', fileoutpath.to_s]) unless Args.debug
    else
      command = [MkvMerge, Config['mkvmerge'], '-o', fileoutpath.to_s, '=', file]
      command.flatten!
      command.compact!
      Util::Program.runprogram(command) unless Args.debug
    end
    convenience.genvi if Args.gvi && fileoutpath.exist?
    convenience.backup if Args.backup
  end
end
