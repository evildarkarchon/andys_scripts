#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'
require 'shellwords'
require 'subprocess'
require 'pathname'
require 'fileutils'
require 'filemagic'

require_relative 'andyrb/mood'
require_relative 'andyrb/util'

class Options
  def self.parse(args)
    options = OpenStruct.new
    # options.quality = '80'
    options.verbose = false
    options.lossy = false
    options.lossless = false
    options.preset = 'default'
    options.outputdir = Pathname.getwd
    # options.backup = Pathname.getwd.join('Original Files')
    options.backup = nil
    options.nobackup = false
    options.archive = nil
    options.backuparchive = Pathname.getwd.join("Original Files/#{Pathname.getwd.basename}.7z").to_s
    options.removeoriginal = true
    options.force = false
    options.sort = true

    optparse = OptionParser.new do |opts|
      opts.on('--quality n', 'Quality factor (0-100), 80 is default.') { |q| options.quality = q.to_s }
      opts.on('--verbose', '-v', 'Make convert more chatty.') { options.verbose = true }
      opts.on('--lossy', 'Produce lossy images.') { options.lossy = true }
      opts.on('--lossless', 'Produce lossless images.') { options.lossless = true }
      opts.on('--output-dir DIRECTORY', '-o DIRECTORY', 'Directory to output resulting images (default is current directory)') { |dir| options.outputdir = Pathname.new(dir.to_s) }
      opts.on('--backup-dir DIRECTORY', '-b DIRECTORY', 'Directory to move source images to.') { |dir| options.backup = Pathname.new(dir.to_s) }
      opts.on('--no-backup', 'Disable Backup.') { options.nobackup = true }
      opts.on('--archive FILENAME', 'Put the resulting images into a 7z archive.') { |archive| options.archive = archive }
      opts.on('--backup-archive FILENAME', 'Put the original images into a 7z archive.') do |archive|
        options.backuparchive = archive unless archive == 'none'
        options.backuparchive = nil if archive == 'none'
      end
      opts.on('--no-remove-original', 'Disables removing the original file when making archives') { options.removeoriginal = false }
      opts.on('--force', '-f', 'Remove any files with the same name as the resulting file.') { options.force = true }
      opts.on('--no-sort', "Don't sort the argument list.") { options.sort = false }
    end
    optparse.parse!(args)
    options
  end
end

ARGV.compact! if ARGV.respond_to?(:compact!)
Args = Options.parse(ARGV)

Args.files = ARGV unless Args.sort
Args.files = Util::SortEntries.sort(ARGV) if Args.sort
Args.files.delete_if { |e| e.include? '*.' }

Args.nobackup = true if Args.removeoriginal && Args.backuparchive
# Args.lossy = true if !Args.lossy && !Args.lossless
raise "Can't have both Lossy and Lossless modes active" if Args.lossy && Args.lossless
SevenZ = Util::FindApp.which('7za')
Convert = Util::FindApp.which('convert')
raise 'convert not found.' if Convert.nil?
if defined?(Args.backup) && Args.backup.respond_to?(:directory?)
  Args.backup.mkpath unless (Args.backup.directory? && !Args.backup.file?) || Args.nobackup
end
Args.outputdir.mkpath unless Args.outputdir.directory? && !Args.outputdir.file?
raise "#{Args.outputdir} is not a directory." unless Args.outputdir.directory? && !Args.outputdir.file?
if defined?(Args.backup) && Args.backup.respond_to?(:directory?)
  raise "#{Args.backup} is not a directory." unless (Args.backup.directory? && !Args.backup.file?) || Args.nobackup
end
if defined?(Args.backup) && Args.backup.respond_to?(:directory?)
  Args.backup = Args.backup.realpath unless Args.nobackup
end
class Command
  attr_reader :list, :outpath, :filepath
  def initialize(filename)
    @filepath = Pathname.new(filename).realpath
    ext = @filepath.extname.downcase
    magic = FileMagic.new(:mime_type)
    @outpath = Pathname.new(Args.outputdir).realpath + Pathname.new(filepath.basename.to_s).sub_ext('.webp').to_s
    lossless_mime = ['image/png', 'image/gif', 'image/tiff', 'image/x-pcx', 'application/tga', 'application/x-tga']
    lossless_mime << ['application/x-targa', 'image/tga', 'image/x-tga', 'image/targa', 'image/x-targa']
    lossless_mime << 'image/vnd.adobe.photoshop'
    lossless_mime.flatten!
    lossless_mime.compact!
    raw = ['.3fr', '.ari', '.arw', '.srf', '.sr2', '.bay', '.crw', '.cr2', '.cap']
    raw << ['.iiq', '.eip', '.dcs', '.dcr', '.drf', '.k25', '.kdc', '.dng', '.erf', '.fff', '.mef', '.mdc', '.mos', '.mrw']
    raw << ['.nef', '.nrw', '.orf', '.pef', '.ptx', '.pxn', '.r3d', '.raf', '.raw', '.rw2', '.rwl', '.rwz', '.srw', '.x3f']
    raw.flatten!
    raw.compact!
    lossless = ['-define', 'webp:lossless=true']
    lossymode = Args.lossy
    losslessmode = Args.lossless

    if (lossless_mime.include?(magic.file(@filepath.to_s)) || raw.include?(ext)) && !lossymode
      lossymode = false
      losslessmode = true
      Args.lossy = false
    end

    losslessmode = false if lossymode

    losslessmode = true if Args.lossless
    lossymode = false if losslessmode
    lossymode = true unless losslessmode
    # puts lossymode
    # puts losslessmode
    @list = [Convert, @filepath.to_s]
    @list << ['-quality', Args.quality] if defined?(Args.quality) && Args.quality
    @list << lossless if losslessmode
    @list << ['-define', 'webp:thread-level=1']
    @list << ['-verbose'] if Args.verbose
    @list << @outpath.to_s
    @list.flatten!
    @list.compact!
  end
end

Args.files.each do |file|
  cmdline = Command.new(file)
  archivepath = Pathname.new(Args.archive) if Args.archive
  puts Mood.happy("Creating directory #{archivepath.parent}") if Args.archive && !archivepath.parent.mkpath.directory?
  archivepath.parent.mkpath if Args.archive && !archivepath.parent.mkpath.directory?
  backuparchivepath = Pathname.new(Args.backuparchive) if Args.backuparchive
  puts Mood.happy("Creating directory #{backuparchivepath.parent}") if Args.backuparchive && !backuparchivepath.parent.directory?
  backuparchivepath.parent.mkpath if Args.backuparchive && !backuparchivepath.parent.directory?
  if cmdline.outpath.exist? && !Args.force
    puts Mood.neutral("#{cmdline.outpath} already exists, skipping.")
    next
  elsif cmdline.outpath.exist? && Args.force
    puts Mood.neutral("Force mode active, deleting #{cmdline.outpath}")
    Fileutils.rm(cmdline.outpath.to_s)
  end
  puts Mood.happy("Converting #{cmdline.filepath.basename} to #{cmdline.outpath}")
  begin
    Util::Program.runprogram(cmdline.list)
  rescue Subprocess::NonZeroExit => e
    puts Mood.sad("#{file} was not able to be converted, skipping.")
    FileUtils.rm(cmdline.outpath.to_s) if cmdline.outpath.exist?
    puts e.message
    next
  rescue Interrupt => e
    FileUtils.rm(cmdline.outpath.to_s) if cmdline.outpath.exist?
    exit 1
  end
  if Args.archive
    puts Mood.happy("Adding #{cmdline.outpath} to #{archivepath}")
    begin
      Util::Program.runprogram([SevenZ, 'a', Args.archive, cmdline.outpath.to_s])
    rescue Subprocess::NonZeroExit => e
      puts e.message
      raise e
    else
      puts Mood.happy("Removing #{cmdline.outpath}") if Args.removeoriginal
      FileUtils.rm(cmdline.outpath.to_s) if Args.removeoriginal
    end
  end
  if Args.backuparchive
    puts Mood.happy("Adding #{cmdline.filepath} to #{backuparchivepath}")
    begin
      Util::Program.runprogram([SevenZ, 'a', Args.backuparchive, cmdline.filepath.to_s])
    rescue Subprocess::NonZeroExit => e
      puts e.message
      raise e
    else
      puts Mood.happy("Removing #{cmdline.filepath}") if Args.removeoriginal
      FileUtils.rm(cmdline.filepath.to_s) if Args.removeoriginal
    end
  end
  next if Args.nobackup
  next if Args.backuparchive && !Args.removeoriginal
  next unless Args.backup.respond_to?(:exist?)
  puts Mood.happy("Moving #{cmdline.filepath.basename} to #{Args.backup}")
  FileUtils.mv(file, Args.backup.to_s)
end
