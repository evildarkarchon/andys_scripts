#!/usr/bin/env ruby
# frozen_string_literal: true
require 'ostruct'
require 'optparse'
require 'shellwords'
require 'subprocess'
require 'pathname'
require 'fileutils'
require 'filemagic'

require_relative 'andyrb/mood'
require_relative 'andyrb/core/cleanup'
require_relative 'andyrb/util/findapp'
require_relative 'andyrb/util/program'
require_relative 'andyrb/util/sort'

class Options
  def self.parse(args)
    options = OpenStruct.new
    # options.quality = '80'
    options.verbose = false
    options.lossy = nil
    options.lossless = nil
    options.preset = 'default'
    options.outputdir = Pathname.getwd
    options.backup = nil
    options.nobackup = false
    options.archive = nil
    options.backuparchive = Pathname.getwd.join("Original Files/#{Pathname.getwd.basename}.7z").to_s
    options.removeoriginal = true
    options.force = false
    options.sort = true

    optparse = OptionParser.new do |opts|
      opts.on('--quality [n]', '-q [n]', 'Quality factor (0-100), 80 is default.') { |q| options.quality = q.to_s }
      opts.on('--verbose', '-v', 'Make convert more chatty.') { options.verbose = true }
      opts.on('--lossy', 'Produce lossy images.') do
        options.lossy = true
        options.lossless = false
      end
      opts.on('--lossless', 'Produce lossless images.') do
        options.lossless = true
        options.lossy = false
      end
      opts.on('--output-dir [DIRECTORY]', '-o [DIRECTORY]', 'Directory to output resulting images (default is current directory)') { |dir| options.outputdir = Pathname.new(dir.to_s) }
      opts.on('--backup-dir [DIRECTORY]', '-b [DIRECTORY]', 'Directory to move source images to.') { |dir| options.backup = Pathname.new(dir.to_s) }
      opts.on('--no-backup', 'Disable Backup.') { options.nobackup = true }
      opts.on('--archive [FILENAME]', 'Put the resulting images into a 7z archive.') { |archive| options.archive = archive }
      opts.on('--backup-archive [FILENAME]', 'Put the original images into a 7z archive.') do |archive|
        options.backuparchive = archive == 'none' ? nil : archive
      end
      opts.on('--no-remove-original', 'Disables removing the original file when making archives') { options.removeoriginal = false }
      opts.on('--force', '-f', 'Remove any files with the same name as the resulting file.') { options.force = true }
      opts.on('--no-sort', "Don't sort the argument list.") { options.sort = false }
    end
    optparse.parse!(args)
    options
  end
end

Args = Options.parse(ARGV)
ARGV.cleanup!(unique: false)
# Args.files = ARGV unless Args.sort
# Args.files = Util::SortEntries.sort(ARGV) if Args.sort
Args.files = Args.sort ? Util.sort(ARGV) : ARGV

Args.nobackup = true if Args.removeoriginal && Args.backuparchive
Args.lossy = true if !Args.lossy && !Args.lossless
raise "Can't have both Lossy and Lossless modes active" if Args.lossy && Args.lossless
# SevenZ = Util::FindApp.which('7za')
# Convert = Util::FindApp.which('convert')

Args.outputdir.mkpath unless Args.outputdir.exist? && Args.outputdir.directory? && !Args.outputdir.file?
raise "#{Args.outputdir} is not a directory." unless Args.outputdir.directory?

case
when Args.backup && Args.backup.respond_to?(:directory?)
  Args.backup.mkpath unless Args.backup.directory? || Args.nobackup
  raise "#{Args.backup} is not a directory." unless Args.backup.directory? || Args.nobackup
  Args.backup = Args.backup.realpath unless Args.nobackup
end

class Command
  attr_reader :list, :outpath, :filepath
  def initialize(filename)
    @filepath = Pathname.new(filename).realpath.freeze
    ext = @filepath.extname.downcase
    magic = FileMagic.new(:mime_type)
    @outpath = Pathname.new(Args.outputdir).realpath + Pathname.new(filepath.basename.to_s).sub_ext('.webp').to_s
    @outpath.freeze

    lossless_mime = %w(image/png image/gif image/tiff image/x-pcx application/tga application/x-tga application/x-targs image/tga image/x-tga image/targa image/x-targa image/vnd.adobe.photoshop)
    lossless_mime.cleanup!(unique: false)
    lossless_mime.freeze

    raw = %w(.3fr .ari .arw .srf .sr2 .bay .crw .cr2 .cap .iiq .eip .dcs .dcr .drf .k25 .kdc .dng .erf .fff .mef .mdc .mos .mrw)
    raw += %w(.nef .nrw .orf .pef .ptx .pxn .r3d .raf .raw .rw2 .rwl .rwz .srw .x3f)
    raw.cleanup!(unique: false)
    raw.freeze

    # lossless = ['-define', 'webp:lossless=true']
    lossless = %w(-define webp:lossless=true).freeze
    lossymode = Args.lossy
    losslessmode = Args.lossless

    if (lossless_mime.include?(magic.file(@filepath.to_s)) || raw.include?(ext)) && !lossymode
      lossymode = false
      losslessmode = true
      Args.lossy = false
      Args.lossless = true
    end

    losslessmode = false if lossymode

    losslessmode = true if Args.lossless
    lossymode = losslessmode ? false : true

    lossymode.freeze
    losslessmode.freeze
    # puts lossymode
    # puts losslessmode
    Util::FindApp.which('convert') do |c|
      raise 'convert not found or is not executable.' unless c && File.executable?(c)
      @list = %W(#{c} #{filepath})
      @list << %W(-quality #{Args.quality})
      @list << lossless if losslessmode
      @list << %w(-define webp:thread-level=1)
      @list << '-verbose' if Args.verbose
      @list << @outpath.to_s
      @list.cleanup!(unique: false)
      @list.freeze
    end
  end
end

def backuparchive
  backuparchivepath = Pathname.new(Args.backuparchive).freeze
  case
  when backarchivepath.parent.exist? && !backuparchive.parent.directory?
    raise "#{backuparchivepath.parent} is not a directory."
  when !backuparchivepath.parent.directory?
    puts Mood.happy("Creating directory #{backuparchivepath.parent}")
    backuparchivepath.parent.mkpath
  end
  puts Mood.happy("Backing up original files to #{backuparchivepath}")

  paths = Args.files.dup
  paths.map! { |i| Pathname.new(i) }
  paths.freeze

  begin
    Util::FindApp.which('7za') do |z|
      z.freeze
      raise '7za not found or is not executable.' if (Args.backuparchive && !z) || (Args.backuparchive && z && !File.executable?(z))
      Util::Program.runprogram(%W(#{z} a #{Args.backuparchive} #{paths.join(' ')}))
    end
  rescue Subprocess::NonZeroExit => e
    puts e.message
    raise e
  else
    if Args.removeoriginal
      paths.each do |file|
        puts Mood.happy("Removing #{file}")
        file.delete
      end
    end
  end
end

def archive
  archivepath = Pathname.new(Args.archive)
  puts Mood.happy("Creating directory #{archivepath.parent}") unless archivepath.parent.directory?
  archivepath.parent.mkpath unless archivepath.parent.directory?
  archivepath = archivepath.realpath
  archivepath.freeze

  paths = Args.files.dup
  paths.map! { |file| Pathname.new(file).realpath.sub_ext('.webp').to_s }
  paths.freeze

  puts Mood.happy("Adding files to #{archivepath}")
  begin
    # Util::Program.runprogram([SevenZ, 'a', Args.archive, paths.join(' ')])
    Util::FindApp.which('7za') { |z| Util::Program.runprogram(%W(#{z} a #{Args.archive} paths.join(' '))) }
  rescue Subprocess::NonZeroExit, Interrupt => e
    puts e.message
    raise e
  else
    if Args.removeoriginal
      paths.each do |file|
        file.freeze
        puts Mood.happy("Removing #{file}")
        file.delete
      end
    end
  end
end

Args.files.each do |file|
  file.freeze
  cmdline = Command.new(file)
  outname = cmdline.outpath.to_s.freeze
  if cmdline.outpath.exist? && !Args.force
    puts Mood.neutral { "#{cmdline.outpath} already exists, skipping." }
    next
  elsif cmdline.outpath.exist? && Args.force
    puts Mood.neutral { "Force mode active, deleting #{cmdline.outpath}" }
    FileUtils.rm(outname)
  end

  puts Mood.happy("Converting #{cmdline.filepath} to #{cmdline.outpath.basename}")
  begin
    Util::Program.runprogram(cmdline.list)
  rescue Subprocess::NonZeroExit => e
    puts Mood.sad("#{file} was not able to be converted, skipping.")
    FileUtils.rm(outname) if cmdline.outpath.exist?
    puts e.message
    next
  rescue Interrupt => e
    FileUtils.rm(outname) if cmdline.outpath.exist?
    raise e
  end

  next if Args.nobackup
  next unless Args.backup.respond_to?(:exist?)
  puts Mood.happy("Moving #{cmdline.filepath.basename} to #{Args.backup}")
  FileUtils.mv(file, Args.backup.to_s)
end
backuparchive if Args.backuparchive
archive if Args.archive
