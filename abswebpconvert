#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'
require 'shellwords'
require 'subprocess'
require 'pathname'
require 'fileutils'
require 'filemagic'

require_relative 'andyrb/mood'
require_relative 'andyrb/util'

class Options
  def self.parse(args)
    options = OpenStruct.new
    # options.quality = '80'
    options.verbose = false
    options.lossy = nil
    options.lossless = nil
    options.preset = 'default'
    options.outputdir = Pathname.getwd
    # options.backup = Pathname.getwd.join('Original Files')
    options.backup = nil
    options.nobackup = false
    options.archive = nil
    options.backuparchive = Pathname.getwd.join("Original Files/#{Pathname.getwd.basename}.7z").to_s
    options.removeoriginal = true
    options.force = false
    options.sort = true

    optparse = OptionParser.new do |opts|
      opts.on('--quality [n]', '-q [n]', 'Quality factor (0-100), 80 is default.') { |q| options.quality = q.to_s }
      opts.on('--verbose', '-v', 'Make convert more chatty.') { options.verbose = true }
      opts.on('--lossy', 'Produce lossy images.') do
        options.lossy = true
        options.lossless = false
      end
      opts.on('--lossless', 'Produce lossless images.') do
        options.lossless = true
        options.lossy = false
      end
      opts.on('--output-dir [DIRECTORY]', '-o [DIRECTORY]', 'Directory to output resulting images (default is current directory)') { |dir| options.outputdir = Pathname.new(dir.to_s) }
      opts.on('--backup-dir [DIRECTORY]', '-b [DIRECTORY]', 'Directory to move source images to.') { |dir| options.backup = Pathname.new(dir.to_s) }
      opts.on('--no-backup', 'Disable Backup.') { options.nobackup = true }
      opts.on('--archive [FILENAME]', 'Put the resulting images into a 7z archive.') { |archive| options.archive = archive }
      opts.on('--backup-archive [FILENAME]', 'Put the original images into a 7z archive.') do |archive|
        options.backuparchive = archive unless archive == 'none'
        options.backuparchive = nil if archive == 'none'
      end
      opts.on('--no-remove-original', 'Disables removing the original file when making archives') { options.removeoriginal = false }
      opts.on('--force', '-f', 'Remove any files with the same name as the resulting file.') { options.force = true }
      opts.on('--no-sort', "Don't sort the argument list.") { options.sort = false }
    end
    optparse.parse!(args)
    options
  end
end

Args = Options.parse(ARGV)
ARGV.compact! if ARGV.respond_to?(:compact!)
Args.files = ARGV unless Args.sort
Args.files = Util::SortEntries.sort(ARGV) if Args.sort

Args.nobackup = true if Args.removeoriginal && Args.backuparchive
# Args.lossy = true if !Args.lossy && !Args.lossless
raise "Can't have both Lossy and Lossless modes active" if Args.lossy && Args.lossless
# SevenZ = Util::FindApp.which('7za')
# Convert = Util::FindApp.which('convert')

Args.outputdir.mkpath unless Args.outputdir.exist? && Args.outputdir.directory? && !Args.outputdir.file?
raise "#{Args.outputdir} is not a directory." unless Args.outputdir.directory?

case
when Args.backup && Args.backup.respond_to?(:directory?)
  Args.backup.mkpath unless Args.backup.directory? || Args.nobackup
  raise "#{Args.backup} is not a directory." unless Args.backup.directory? || Args.nobackup
  Args.backup = Args.backup.realpath unless Args.nobackup
end

class Command
  attr_reader :list, :outpath, :filepath
  def initialize(filename)
    @filepath = Pathname.new(filename).realpath
    ext = @filepath.extname.downcase
    magic = FileMagic.new(:mime_type)
    @outpath = Pathname.new(Args.outputdir).realpath + Pathname.new(filepath.basename.to_s).sub_ext('.webp').to_s
    lossless_mime = %w(image/png image/gif image/tiff image/x-pcx application/tga application/x-tga application/x-targs image/tga image/x-tga image/targa image/x-targa image/vnd.adobe.photoshop)
    lossless_mime.flatten!
    lossless_mime.compact!

    raw = %w(.3fr .ari .arw .srf .sr2 .bay .crw .cr2 .cap .iiq .eip .dcs .dcr .drf .k25 .kdc .dng .erf .fff .mef .mdc .mos .mrw)
    raw += %w(.nef .nrw .orf .pef .ptx .pxn .r3d .raf .raw .rw2 .rwl .rwz .srw .x3f)
    raw.flatten!
    raw.compact!

    # lossless = ['-define', 'webp:lossless=true']
    lossless = %w(-define webp:lossless=true)
    lossymode = Args.lossy
    losslessmode = Args.lossless

    if (lossless_mime.include?(magic.file(@filepath.to_s)) || raw.include?(ext)) && !lossymode
      lossymode = false
      losslessmode = true
      Args.lossy = false
    end

    losslessmode = false if lossymode

    losslessmode = true if Args.lossless
    lossymode = false if losslessmode
    lossymode = true unless losslessmode
    # puts lossymode
    # puts losslessmode
    Util::FindApp.which('convert') do |c|
      raise 'convert not found or is not executable.' unless c && File.executable?(c)
      # @list = [Convert, @filepath.to_s]
      @list = %W(#{c} #{filepath})
      @list += %W(-quality #{Args.quality}) # ['-quality', Args.quality] if defined?(Args.quality) && Args.quality
      @list += lossless if losslessmode
      @list += %w(-define webp:thread-level=1) # ['-define', 'webp:thread-level=1']
      @list += '-verbose' if Args.verbose
      @list += @outpath.to_s
      @list.flatten!
      @list.compact!
    end
  end
end

def backuparchive
  backuparchivepath = Pathname.new(Args.backuparchive)
  case
  when backarchivepath.parent.exist? && !backuparchive.parent.directory?
    raise "#{backuparchivepath.parent} is not a directory."
  when !backuparchivepath.parent.directory?
    puts Mood.happy("Creating directory #{backuparchivepath.parent}")
    backuparchivepath.parent.mkpath
  end
  puts Mood.happy("Backing up original files to #{backuparchivepath}")

  paths = []
  Args.files.each do |file|
    paths += Pathname.new(file).realpath.to_s
  end

  begin
    Util::FindApp.which('7za') do |z|
      raise '7za not found or is not executable.' if Args.backuparchive && !z || Args.backuparchive && z && !File.executable?(z)
      Util::Program.runprogram(%W(#{z} a #{Args.backuparchive} #{paths.join(' ')}))
    end
  rescue Subprocess::NonZeroExit => e
    puts e.message
    raise e
  else
    if Args.removeoriginal
      paths.each do |file|
        puts Mood.happy("Removing #{file}")
        FileUtils.rm(file)
      end
    end
  end
end

def archive
  archivepath = Pathname.new(Args.archive)
  puts Mood.happy("Creating directory #{archivepath.parent}") unless archivepath.parent.directory?
  archivepath.parent.mkpath unless archivepath.parent.directory?
  archivepath = archivepath.realpath
  paths = []
  Args.files.each do |file|
    paths += Pathname.new(file).realpath.sub_ext('.webp').to_s
  end
  puts Mood.happy("Adding files to #{archivepath}")
  begin
    Util::Program.runprogram([SevenZ, 'a', Args.archive, paths.join(' ')])
  rescue Subprocess::NonZeroExit => e
    puts e.message
    raise e
  else
    if Args.removeoriginal
      paths.each do |file|
        puts Mood.happy("Removing #{file}")
        FileUtils.rm(file)
      end
    end
  end
end

Args.files.each do |file|
  cmdline = Command.new(file)
  outname = cmdline.outpath.to_s
  if cmdline.outpath.exist? && !Args.force
    puts Mood.neutral("#{cmdline.outpath} already exists, skipping.")
    next
  elsif cmdline.outpath.exist? && Args.force
    puts Mood.neutral("Force mode active, deleting #{cmdline.outpath}")
    FileUtils.rm(outname)
  end

  puts Mood.happy("Converting #{cmdline.filepath} to #{cmdline.outpath.basename}")
  begin
    Util::Program.runprogram(cmdline.list)
  rescue Subprocess::NonZeroExit => e
    puts Mood.sad("#{file} was not able to be converted, skipping.")
    FileUtils.rm(outname) if cmdline.outpath.exist?
    puts e.message
    next
  rescue Interrupt => e
    FileUtils.rm(outname) if cmdline.outpath.exist?
    exit 1
  end

  next if Args.nobackup
  next unless Args.backup.respond_to?(:exist?)
  puts Mood.happy("Moving #{cmdline.filepath.basename} to #{Args.backup}")
  FileUtils.mv(file, Args.backup.to_s)
end
backuparchive if Args.backuparchive
archive if Args.archive
